<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>android on 烂杯的博客</title>
    <link>https://cgcel.github.io/tags/android/</link>
    <description>Recent content in android on 烂杯的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This is a customized copyright.</copyright>
    <lastBuildDate>Mon, 10 Feb 2020 16:01:35 +0800</lastBuildDate>
    <atom:link href="https://cgcel.github.io/tags/android/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ViewPager的嵌套滑动冲突问题解决</title>
      <link>https://cgcel.github.io/posts/2020/02/10/viewpager%E7%9A%84%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/viewpager%E7%9A%84%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Mon, 10 Feb 2020 16:01:35 +0800</pubDate>
      <guid>https://cgcel.github.io/posts/2020/02/10/viewpager%E7%9A%84%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/viewpager%E7%9A%84%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</guid>
      <description>开篇 在上一篇博客 [[2020-02-08-ViewPager禁用滑动实践和总结|ViewPager禁用滑动实践和总结]] 中我总结了禁用 ViewPager 滑动的解决方案, 这也是网上示例的主流解决方法, 但是使用这个方法后, 导致项目中 Fragment 的 RecyclerView 与 ViewPager 的滑动出现冲突, 无法实现效果, 如下图:
从上图可以看到按照上一篇博客中重写子 Fragment 中的 ViewPager 的 OnInterceptTouchEvent() 和 onTouchEvent() 后, 于子 Fragment 中显示的 RecyclerView 上滑动将无法使用 Activity 的 ViewPager 切换, 只能在 RecyclerView 没有覆盖到的边框位置进行滑动, 这样的操作无疑非常不舒适, 于是我只能继续在网上搜索相关解决方案, 现总结如下.
修改步骤 与上一篇博客思路一样, 只需要重写 ViewPager 的 canScrollHorizontally() 函数即可, 代码如下:
public class UnScrollableViewPager extends ViewPager { private boolean scrollable = false; public UnScrollableViewPager(Context context) { super(context); } public UnScrollableViewPager(Context context, AttributeSet attrs) { super(context, attrs); } @Override // 重写该函数, 用于判断是否能水平滑动 public boolean canScrollHorizontally(int direction) { return scrollable; // false表示已经到最右 } } 修改完代码后重新运行, 效果如下, 可见已经实现了预期的效果.</description>
    </item>
    <item>
      <title>ViewPager禁用滑动实践和总结</title>
      <link>https://cgcel.github.io/posts/2020/02/08/viewpager%E7%A6%81%E7%94%A8%E6%BB%91%E5%8A%A8%E5%AE%9E%E8%B7%B5%E5%92%8C%E6%80%BB%E7%BB%93/viewpager%E7%A6%81%E7%94%A8%E6%BB%91%E5%8A%A8%E5%AE%9E%E8%B7%B5%E5%92%8C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 08 Feb 2020 22:00:39 +0800</pubDate>
      <guid>https://cgcel.github.io/posts/2020/02/08/viewpager%E7%A6%81%E7%94%A8%E6%BB%91%E5%8A%A8%E5%AE%9E%E8%B7%B5%E5%92%8C%E6%80%BB%E7%BB%93/viewpager%E7%A6%81%E7%94%A8%E6%BB%91%E5%8A%A8%E5%AE%9E%E8%B7%B5%E5%92%8C%E6%80%BB%E7%BB%93/</guid>
      <description>开篇 接触 Android 有一段时间了, 起因是帮同事一起做项目, 顺便自己学习, 于是项目一直断断续续进行, 很多控件和功能都是参考《第一行代码》还有网上的例子慢慢探索的, 最近一直在钻 TabLayout 的点击切换, 也就是禁用 ViewPager 的左右滑动切换的牛角尖, 具体效果如下图所示. 网上的例子实在是太千篇一律了, 导致有些地方只要其中一篇阅读量很多的博客没有, 其他转载或者借鉴的博客就都不会写🤪, 下面就记录一下我在原有 TabLayout&amp;amp;ViewPager 基础上修改的示例.
实现步骤 1. 重写ViewPager 如果要实现禁用滑动的效果, 那么就需要重写 ViewPager, 因为默认是开启滑动的, 具体代码如下:
public class NoScrollingViewPager extends ViewPager { private boolean scrollable = false; public NoScrollingViewPager(Context context) { super(context); } public NoScrollingViewPager(Context context, AttributeSet attrs) { super(context, attrs); } @Override // 重写以下两个TouchEvent, 返回false以禁用滑动动作的监听 public boolean onInterceptTouchEvent(MotionEvent ev) { return scrollable; } @Override public boolean onTouchEvent(MotionEvent ev) { return scrollable; } } 以上重写代码都是千篇一律的, 只需要重写两个函数.</description>
    </item>
    <item>
      <title>Pixel 2XL root方案记录</title>
      <link>https://cgcel.github.io/posts/2018/09/09/pixel-2xl-root%E6%96%B9%E6%A1%88%E8%AE%B0%E5%BD%95/pixel-2xl-root%E6%96%B9%E6%A1%88%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Sun, 09 Sep 2018 00:00:00 +0000</pubDate>
      <guid>https://cgcel.github.io/posts/2018/09/09/pixel-2xl-root%E6%96%B9%E6%A1%88%E8%AE%B0%E5%BD%95/pixel-2xl-root%E6%96%B9%E6%A1%88%E8%AE%B0%E5%BD%95/</guid>
      <description>开篇 回顾我的刷机历程, 每次都是有了想法之后就行动起来了, 经历的是一次又一次的真香警告. 而本次 root 的想法的起因是黑域越来越难用, 让我想用回绿守, 本想着等 9.1 出来之后再 root, 但是每次我都会等不及&amp;hellip; 然后果不其然的踩坑了.
刷机环境以及刷机包准备 USB驱动 adb环境 TWRP Magisk 其中, twrp 较新版本刷入之后有 bug, 上 youtube 看过教程后, 决定采用 twrp3.2.1.2, 下载时需要下载.img以及.zip文件.
具体步骤 进入命令行
进入 fastboot 界面
$ adb reboot bootloader 解 bootloader 锁
$ fastboot flashing unlock 使用音量键和电源键进行确认, 注意解锁后手机所有数据将会被清除, 要做好备份.
刷入第三方 recovery
$ fastboot boot path/twrp.img 刷入成功后, 重启进入 recovery, 此时还需要进入 install, 选择 twrp.zip 包再进行刷入. 缺少这一步的话, 下一次重启还会回到官方recovery.
刷入 magisk 在 twrp 的 install 页面选择事先存入手机的 magisk.</description>
    </item>
    <item>
      <title>Gcm-for-Mojo搭建总结</title>
      <link>https://cgcel.github.io/posts/2018/07/06/gcm-for-mojo%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93/gcm-for-mojo%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 06 Jul 2018 00:00:00 +0000</pubDate>
      <guid>https://cgcel.github.io/posts/2018/07/06/gcm-for-mojo%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93/gcm-for-mojo%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93/</guid>
      <description>开篇 最近一直对手机的 3.1GB/3.8GB 的内存占用感到不爽, 想要压缩到 2.8GB 左右, 于是开始填坑 gcm-for-mojo , 这是一个获取网页端微信信息并通过 gcm 推送到客户端的 app, 同时他也支持 mipush, hwpush 等等国内平台的推送, 由于手机是 Pixel 2 XL, 原生系统自然用 gcm 就 ok 了, 微信客户端现在内存占用是越来越大了, 把后台关了也有接近300M, 而使用一些工具替代微信的后台接收信息工作, 自然就达到了省电省内存的效果了.
服务器配置 本人常用微信, 于是就只做了微信的推送, QQ 配置方法类似, 基本上举一反三, 很容易学会. 首先我们在服务器上安装 perl, Ubuntu 16.04 操作如下:
$ sudo apt-get install perl cpanminus git make screen libssl-dev libnet-ssleay-perl libio-socket-ssl-perl 完成后
$ cpanm Mojo::Weixin 我们直接到 GitHub 上看配置步骤, 描述得很详细, 最多几分钟就可以搞定了.
接下来我们新建一个 wx.pl 文件, 命名随意, 内容如下:
use Mojo::Weixin; my $client = Mojo::Weixin-&amp;gt;new(log_encoding=&amp;gt;&amp;#34;utf-8&amp;#34;); $client-&amp;gt;load(&amp;#34;ShowMsg&amp;#34;); $client-&amp;gt;load(&amp;#34;GCM&amp;#34;,data=&amp;gt;{ api_url =&amp;gt; &amp;#39;https://gcm-http.</description>
    </item>
  </channel>
</rss>
