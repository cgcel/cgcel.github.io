[{"content":"\n","date":"2022-10-16T00:16:55+08:00","permalink":"https://cgcel.github.io/posts/2022/10/16/photoprism%E7%9A%84%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8Agooglephotos%E5%9B%BE%E7%89%87%E6%90%AC%E8%BF%90/photoprism%E7%9A%84%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8Agooglephotos%E5%9B%BE%E7%89%87%E6%90%AC%E8%BF%90/","title":"PhotoPrism的部署以及GooglePhotos图片搬运"},{"content":"写在开头 本篇是上一篇 [[通过ZeroTier和Scrcpy远程操控安卓机]] 的续篇, 上篇的方案存在几个缺点:\n由于手机的无线调试不稳定 (网络断开就会关闭, 需要手动重新开启), 由于使用了免费服务 ZeroTier 进行内网穿透, 连接环境在墙内时好时坏, 不稳定 综上的因素导致这个方案总体不稳定, 参考了 Github 上的一篇文章, 本篇记录一个基于 Android 12 和 新版本 Termux 的, 更加稳健的方案, 通过在已 Root 的手机上安装 Termux, 然后在 Termux 中配置 ssh (远程 ssh 操控) 和 frpc (通过私有服务器的 IP 进行反向代理), 实现远程 adb 配对设备并通过 Scrcpy 对手机进行操作.\n硬件准备 有 公网 IP, 并装有 Frps 的服务器 1台 已 Root 的安卓手机 装有 adb 和 scrcpy 的电脑一台 方案使用手机机型为 Oneplus 8T, 运行基于 Android 12.1 的 LineageOS 19.1, 使用 Magisk 25.2 获取 Root 权限.\n配置过程 Termux 安装与配置 1. 安装 F-Droid 首先在手机端下载并安装应用商店 F-Droid, 从中安装最新版 Termux (Google Play 版本落后很多)\n2. 获取存储权限 1 termux-setup-storage 3. 获取 Root 权限与设置 root 账号密码 在 Termux 命令行中获取 Root 权限, 输入:\n1 su 在弹窗中同意 Termux 获取 Root 权限, 进入 su 后, 键入 passwd 设置 root 账号的密码.\n1 passwd 然后重启 Termux 以便于后续的操作.\n4. 更换清华源 1 termux-change-repo 根据 Termux 的 GUI 提示进行操作, 使用空格和回车选择国内源, 这里因为个人习惯选择清华源.\n5. 安装必要包 1 2 apt update \u0026amp;\u0026amp; apt upgrade -y --force-yes pkg install openssh tsu cronie -y 6. (Optional) 开启 SSH 为了方便后续命令行操作, 可以选择先在 Termux 开启 SSH, 便于后续操作. 在 Termux 命令行中输入:\n1 sshd 开启后, 获取手机的局域网 IP, 在桌面端命令行输入以下指令尝试远程连接 (openssh 默认端口为 8022):\n1 ssh root@{局域网IP} -p 8022 如果成功, 将会提示输入接受密钥以及输入密码.\n参考链接:\nhttps://blog.csdn.net/freeking101/article/details/122725389 https://wiki.termux.com/wiki/Main_Page 部署 Frpc 并测试连接 1. 服务器端 Frps 部署 在服务器命令行输入 name -a 查看服务器系统架构. 根据服务器系统架构下载对应的 Frp 版本, 在服务器端解压缩并根据实际情况在 frps.ini 配置 Frps 端口, token. dashboard 等. 配置完成后, 在解压缩的目录命令行输入 ./frps -c ./frps.ini, 查看服务是否正常运行.\n2. 移动端 Frpc 部署 首先在 Termux 中开启手机 adb 调试端口, 默认为 5555:\n1 2 3 4 cd /system/bin sudo ./setprop service.adb.tcp.port 5555 sudo ./stop adbd sudo ./start adbd 下载 Frp linux arm64 版 (现在的安卓机一般都是arm64位的了) 至电脑, 按照 官方文档 以及服务器实际情况配置好 frpc.ini, 将手机通过 USB 连接电脑, 然后将 frpc.ini 和 frpc 复制至 storage/emulated/0/Download 中.\n在 Termux 的解压目录中, 输入 ./frpc -c ./frpc.ini, 观察连接情况.\n实际操作中, 在手机端开启 Frpc 服务时报错: [W] [service.go:82] login to server failed: dial tcp: lookup xx.xx.com on [::1]:53: read udp [::1]:37354-\u0026gt;[::1]:53: read: connection refused\n参考作者答复, 调整 frpc.ini 配置文件可解决.\n3. 电脑端远程连接并操控手机 连接正常后, 在电脑命令行中配对手机:\n1 adb connect {服务器 IP}:{frpc.ini 中配置的 5555 映射端口} 配对成功后, 输入以下指令连接手机, 可根据网络情况自行设置分辨率和比特率等, 参考官方文档:\n1 scrcpy -m 720 -b 2M 4. 配置 Frps service 在服务器中配置 Frps service, 使其更方便操控. 根据 官方文档 完成设置.\n配置定时任务 将文件复制至 Termux 根目录:\n1 2 3 cp storage/downloads/frpc ~/ cp storage/downloads/frpc.ini ~/ chmod +x ./frpc 在根目录, 键入 nano start_adb_frpc 编辑启动脚本:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/data/data/com.termux/files/usr/bin/sh termux-wake-lock # open adb port, ssh cd /system/bin sudo ./setprop service.adb.tcp.port 5555 sudo ./stop adbd sudo ./start adbd sudo sshd # open frp cd ~ sudo killall frpc nohup sudo ./frpc -c ./frpc-pi.ini \u0026gt; ./log.txt 2\u0026gt;\u0026amp;1 \u0026amp; killall crond crond 赋予可执行权限:\n1 chmod +x ./start_adb_frpc 在根目录中, 键入 ./start_adb_frpc 即可启动服务.\n最后, 进入 crontab 配置定时任务, 确保服务后台存活:\n1 2 # 进入 crontab crontab -e 在 crontab 中配置定时任务:\n1 2 # 每半个小时重启脚本 */30 * * * * ~/start_adb_frpc 至此, 所有配置已经完成.\n总结 配置完成后, 已经使用这个方案进行了两次远程操作, 全程稳定流畅, 已经能够完美满足我个人的使用要求, 后续准备将服务移植至我的 一加6 中, 一加 8T 就继续作为备机用来刷机玩.\n","date":"2022-09-28T09:59:57+08:00","permalink":"https://cgcel.github.io/posts/2022/09/28/android12%E7%9A%84termux%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8frpc%E8%AE%B0%E5%BD%95/android12%E7%9A%84termux%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8frpc%E8%AE%B0%E5%BD%95/","title":"Termux 安装并使用 Frpc"},{"content":"写在开头 最近由于有需要远程操控手机的需求, 目前我所知道的第三方服务 TeamViewer, AirDroid, ToDesk 等均可支持远程操控安卓设备, 但是也存在一些缺点, 比如墙内连接不稳定延时高, 需要注册账号, 需要付费, 需要 Root 等, 作为折腾党, 也趁着8t刚刷上 LineageOS19.1 的这段时间重新试了一下通过安装, 配置 ZeroTier 和 Scrcpy 完成对手机的操控, 其实去年就做了这样的尝试, 但是没有做记录, 这次就趁热打铁水一篇博客吧.\n软件安装 软件安装分为操控端设备 (实例为带图形桌面的电脑), 被控端设备 (安卓手机, 实例为运行 Android 12.1 的一加8T):\n操控端 ZeroTier 1.10.1 Scrcpy 1.24 adb 1.0.41 1 其中, Windows 环境在使用 adb 时遇到了 adb 版本过低无法使用 `adb pair` 指令的情况. 按照官方文档操作会输出一大串 adb 使用指引, 忘记截图了, 解决方法是更新安装的 platform-tools 文件夹内的 adb 版本. 如果更新了之后还是出现这种情况, 应该在电脑环境中检查是否有其他自带了 adb 的软件也注册了环境变量, 将其从环境变量中移除即可, 如果选择不移除, 可以直接在 adb 的安装目录启动命令行, 此时将会优先使用目录下的 adb.exe. 被控端 ZeroTier One 1.8.9-1 (Google Play 安装) ZeroTier 网络注册 本方案采用 ZeroTier 构建设备点对点连接, 实现内网穿透. 要使用 ZeroTier, 应首先注册账号并创建 Network.\n创建好网络后, 在 操控端 以及 被控端 开启 ZeroTier 客户端并加入网络, 然后通过 ZeroTier 官网的个人控制台允许设备接入网络.\n设备在 ZeroTier 网络中的虚拟 IP 可以在控制台查询, 或者在设备中自行查询比对. Ok, 准备就绪, 可以开始准备操控手中的安卓设备了!\n配置无线调试 (Wireless Debugging) 安卓设备从 Android 11 开始支持通过 WiFi 调试设备, 参考链接, 根据文档描述, 我们首先开启手机的 开发者选项, 然后勾选 无线调试, 勾选后进入无线调试的子菜单, 点击 使用配对码配对设备, 此时手机会弹窗提示当前设备的 WLAN配对码, IP 地址和端口, 记下这些信息. 在操控端电脑开启命令行, 输入 adb pair IP地址:端口, 此处的信息为第一步获得的信息, 回车后继续根据提醒输入六位数字配对码, 此时不出意外的话将完成配对工作. (Optional) 存在配对成功后 adb 不会自动连接设备的情况, 此时可以在命令行输入 adb connect IP地址:端口, 注意此处的 IP 与端口并非第一步的, 而是进入无线调试子菜单页面显示的 IP 地址和端口. 连接了几次发现这里的端口都是 37995, 不知道是不是固定的端口所以不打码. 连接成功后, 在命令行输入 adb devices 即可看见刚刚配对成功的手机了, 输入 scrcpy 即可远程操控手机了. 总结 接下来只需要保证操控端能一直在线就可以实现随时随地的在外操控家中的手机了. 这个方案应该不算特别折腾, 特别是对我这种经常刷机的人来说其实环境早就装的差不多了, 只需要配对设备就可以了. 但是有一个缺点是: 一旦手机断开与局域网的连接, 重连后大概率会需要重新配对, 此时就需要重新接触手机, 打开设置查看新的配对码和端口了. 所以如果不追求连接质量与性能的话最好还是在电脑装一个模拟器.\n","date":"2022-09-25T11:24:55+08:00","permalink":"https://cgcel.github.io/posts/2022/09/25/%E9%80%9A%E8%BF%87zerotier%E5%92%8Cscrcpy%E8%BF%9C%E7%A8%8B%E6%93%8D%E6%8E%A7%E5%AE%89%E5%8D%93%E6%9C%BA/%E9%80%9A%E8%BF%87zerotier%E5%92%8Cscrcpy%E8%BF%9C%E7%A8%8B%E6%93%8D%E6%8E%A7%E5%AE%89%E5%8D%93%E6%9C%BA/","title":"通过 ZeroTier 和 Scrcpy 远程操控安卓机"},{"content":"写在开头 我的树莓派作为服务器使用已经有一段时间了, 之前安装了一个铝壳被动散热, 在还没进入夏天的5月份, 轻负载时可以突破50度, 这时候用手直接摸散热壳已经是很烫的了.\n由于pi放在了我房间的木桌上, 让我不太敢用力压榨它, 给它更换更好的散热已经是很早就有的想法.\n正巧最近618将至, 我在浏览散热器的时候发现了树莓派机箱的推荐, 大概是下面这种形状:\n其实这种样子的机箱我在咸鱼看过很多次, 不过我觉得外观上比较一般, 让我没有购买的欲望, 于是便萌生了自己设计一个机箱并打印的想法, 正好自己对3D打印建模挺感兴趣, 可以利用这次机会入坑一下, 顺便学习建模.\n网上冲浪之后, 我了解到3D打印主要使用 .stl 格式的模型, 而可以生成这种格式模型的软件也有很多, 比如 Solid Works, Zbrush, Sketchup 等等, 我很快就决定使用 Sketchup 进行建模, 因为我女友可以指导我, 让我更容易上手. 至于模型的打印, 则可以交给有3D打印机的朋友或者网店代工.\n建模部分 灵感来源 在做上述的功课时, 我了解到一个主流的3D打印模型分享站, 国内称之为 T站, 在上面我看到了一个比较感兴趣的 模型:\n看到这个正方体我马上联想到 MC 中 TNT 方块的样子:\n根据T站的马里奥问号箱, 我可以稍作修改, 将模型改成我想要的 TNT 形状, 对于入门学习 Sketchup 建模的我来说是比较好的一个方案.\n建模 在 Sketchup 中新建模型, 然后导入 .stl 文件 抹平原模型中的四边图案 推拉中间白条区域, 准备实现参照模型的凸起部分 连接突起白条, 并根据3D文字进行修改, 将 N 改成像素风格, 然后使用推拉, 在白条上刻字 初步上色看看效果 在上半部分加入凹槽, 使模型更贴近原 TNT 的样子 改造盖子, 还是一样操作先把原模型图案去除然后推拉成平面, 由于树莓派将会安装卧式散热, 盖子设计成了镂空形状, 方便透气 模型打印与加工 打印模型 在找店家打印的同时, 我了解到3D打印机主要分 SLA 和 FDM 这两种.\nFDM是我印象比较深的有喷头的打印机, 通过熔融沉积技术将材料加热并按照轨迹打印模型, 入门打印机大多都是FDM打印机, 这种方法打印的模型表面比较粗糙, 精度较低.\nSLA是最早出现的快速原型制造工艺, 通过光轴移动来打印. SLA工业机型是激光固化成型, 在精度上有FDM机型无法逾越的优势, 可制作各种结构复杂的精密零件和组装件.\n最终, 和店家确定了方案, 采用 SLA 打印机打印, 材料为光敏树脂 (店家推荐用尼龙打印, 可以耐高温, 但出于成本考虑还是选择树脂, 毕竟是我的第一次尝试, 没必要杀鸡用牛刀), 打印费用150元 (原想着几十块解决, 没想到最便宜的也要上百)\n几天后, 模型打印完成, 经过打磨后寄给了我.\n手涂模型 店家的上色费用要200, 比打印费还贵, 所以在同事大佬的建议下我买了水补土和消光, 准备后续上色, 漆料则使用同事友情赞助的水性漆和缓干剂. 不过由于临时行程有变, 一两天内要回东莞了, 喷雾不能带进公共交通, 所以我要赶工直接上色, 手涂完就给我的 pi 装上专属机箱.\n找了两个冻干咖啡盖子用来装漆料, 准备开工 手涂上色, 先找内壁上点红色试试水 外壁简单上了一两层红漆 大佬建议先上白色部分, 避免红色部分修修补补 上完白色后继续补红色, 主体部分除了文字部分基本涂完 盖子粗上色 回到东莞继续, 先把 pi 的散热壳拆了, 还有把散热器装上先看看效果 继续加深盖子颜色, 直到和主题相差无几 上色黑字部分, 以及最后的成品图 组装成品 将装好散热器的 pi 放入箱子, 由于螺丝买的不够长, 暂时无法很好的固定住, 这里先靠外接的线固定住, 后续回来再换螺丝.\n将盖子盖上, 这里的螺丝依旧买小了, 因为我不想用自攻螺丝破坏箱体, 所以就先这样固定.\n插入SD卡, 连接上电源线, 网线以及移动硬盘, 组装工作基本完成\n测试散热 最后到了实战部分, 将cpu温度与之前的数据对比, 轻负载时温度在38-42度之间, 满载时温度在50度左右, 达到了我的预期, 今后也可以放心折腾了.\n后续计划 散热贴更换为硅脂 更换合适尺寸的螺丝与铜柱 打磨重涂, 加上底漆 (水补土) 与保护漆 (消光) ","date":"2022-06-07T20:27:35+08:00","permalink":"https://cgcel.github.io/posts/2022/06/07/pi4tntcase--%E6%88%91%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9C%BA%E7%AE%B1/pi4tntcase--%E6%88%91%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9C%BA%E7%AE%B1/","title":"Pi4TNTCase -- 我的树莓派机箱"},{"content":"开篇 由于最近因为疫情居家健康监测, 还没复工, 我在家边学习边玩. 在家期间看了 ⌈86⌋ 第二季, 简单学了一下 Go, 还有捡回来 Scrapy 学习一下. 说到 Scrapy, 本科的时候就有学习过, 但是当时找的是B站上的中文教程, 感觉教的我一头雾水, 这次从官方文档开始下手, 结合 Google, 感觉一下子清晰明了了许多.\n准备 安装 现在的 Scrapy 安装简单了不少, 几年前在 Windows 端还不能直接用 pip 安装. 现在只需要一句 pip install scrapy 即可.\n编译环境 编译环境当然还是永远的 VS Code.\n实现 计划 大佬提供了一个塞满 URL 的 json 文件给我, 都是小说网站相关的, 既然要爬取小说网站, 就不可避免地要爬取同一本书的多个章节, 于是很容易联想到使用 Scrapy 来实现, 毕竟是一个成名已久的 Python 爬虫框架, 总比我简单粗暴用 requests 来爬好多了.\n那么接下来就是解决以下几个问题, 最后实现整个爬取的功能:\n根据小说主页 URL 获取各章节标题以及 URL 根据章节 URL 爬取章节内容并保存 将 Scrapy 爬取到的内容按顺序排列后, 依次存入 .txt 文件中 开始 首先, 安装完 Scrapy 后, 按照官方文档, 直接在目录启动命令行, 捅过命令行生成项目:\n1 $ scrapy startproject biquge_dl 生成后, 在 spiders/ 子文件夹中新建 fiction_spider.py, 用于编写爬虫代码.\n根据官方的 QuickStart 例程, 首先新建一个 class, 继承 scrapy.Spider, 后续只需要结合源码和文档, 就可以继续写下去了.\n获取小说章节 URL 首先在浏览器打开开发者工具对小说主页进行抓包, 可以看到该网站并没有用到一些 API, 于是准备采用 XPATH 来对章节 URL 进行爬取, 观察到无论多长篇幅的小说, 其章节都在一页中显示, 这无疑降低了部分难度, 拿来练手 scrapy 实在是再合适不过了.\n通过重写 parse(), 对小说主页 html 进行解析并抓取章节 URL.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import scrapy class FictionSpider(scrapy.Spider): def parse(self, response, **kwargs): self.logger.info(\u0026#39;Parse function called on %s\u0026#39;, response.url) fiction_name = response.xpath(\u0026#39;//*[@id=\u0026#34;info\u0026#34;]/h1/text()\u0026#39;).get() section_order = 1 for episode_doc in response.xpath(\u0026#39;//*[@id=\u0026#34;list\u0026#34;]/dl/dd[*]/a\u0026#39;): section_title = episode_doc.xpath(\u0026#39;.//text()\u0026#39;).get() url = episode_doc.xpath(\u0026#39;.//@href\u0026#39;).get() section_url = self.base_url + url request = scrapy.Request( url=section_url, callback=self.parse_content, cb_kwargs=dict()) request.cb_kwargs[\u0026#39;fiction_name\u0026#39;] = fiction_name request.cb_kwargs[\u0026#39;section_order\u0026#39;] = section_order request.cb_kwargs[\u0026#39;section_title\u0026#39;] = section_title section_order += 1 yield request 获取成功后, 将小说名, 章节序号, 章节名作为参数传给 parse_content() 函数, 继而对章节进行爬取.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from bs4 import BeautifulSoup as bs from biquge_dl.items import BiqugeDlItem class FictionSpider(scrapy.Spider): def parse_content(self, response, fiction_name, section_order, section_title): self.logger.info(\u0026#39;Parse content function called on %s\u0026#39;, response.url) contents = response.xpath(\u0026#39;//*[@id=\u0026#34;content\u0026#34;]/text()\u0026#39;).getall() if len(contents) \u0026lt;= 1: soup = bs(response.body, \u0026#39;html.parser\u0026#39;) contents = soup.find_all(\u0026#34;div\u0026#34;, {\u0026#34;class\u0026#34;: \u0026#34;box_con\u0026#34;}).get_text() item = BiqugeDlItem() item[\u0026#39;name\u0026#39;] = fiction_name item[\u0026#39;order\u0026#39;] = section_order item[\u0026#39;title\u0026#39;] = section_title item[\u0026#39;content\u0026#39;] = contents return item Items 的使用 写上述 parse_content() 时发现, 直接使用 scrapy 对小说进行章节爬取, 并按章节名每章下载是很简单的, 只需要直接跑爬虫就可以, 各个章节会乱序下载下来, 但如果想要只下载一份文件, 按顺序存储章节, 那么就需要使用 scrapy 的 items 和 pipelines 了, 这两个 .py 文件会随着一开始命令行创建项目时一并创建, 所以可以很轻易地在 biquge_dl/ 文件夹内找到, 只需要对这两个文件进行重写, 并在 parse_content() 中将内容写进 item 中, 就能实现参数的传递.\n查阅 官方文档, 对 Items 的描述如下:\nThe main goal in scraping is to extract structured data from unstructured sources, typically, web pages. Spiders may return the extracted data as items, Python objects that define key-value pairs.\nScrapy supports multiple types of items. When you create an item, you may use whichever type of item you want. When you write code that receives an item, your code should work for any item type.\n可见 item 可以将提取的数据按一定格式返回, 只需要规划好传入参数, 就可以利用 item 实现排序的操作.\nItem pipeline 的使用 官方文档 这样介绍:\nAfter an item has been scraped by a spider, it is sent to the Item Pipeline which processes it through several components that are executed sequentially.\nEach item pipeline component (sometimes referred as just “Item Pipeline”) is a Python class that implements a simple method. They receive an item and perform an action over it, also deciding if the item should continue through the pipeline or be dropped and no longer processed.\nTypical uses of item pipelines are:\ncleansing HTML data validating scraped data (checking that the items contain certain fields) checking for duplicates (and dropping them) storing the scraped item in a database 意为, 在 spider 抓取一个 item 后, scrapy 通过 Item Pipeline 来处理这个 item, 结合本项目, 只需要将爬取到的 item 交由 Item Pipeline 统一处理即可实现按顺序存储的功能.\n传递章节参数, 实现按顺序保存 为了实现章节按照顺序写入, 首先确认实现思路:\n在 items.py 定义一个 Item 类, 自定义传入参数, 以供调用 在 pipelines.py 定义一个 Pipeline 类, 对传入的 item 进行处理 items.py 打开 items.py, 按照例子创建一个继承 scrapy.Item 的 BiqugeDlItem 类, 对类进行参数的定义:\n1 2 3 4 5 6 7 8 class BiqugeDlItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() name = scrapy.Field() order = scrapy.Field() title = scrapy.Field() content = scrapy.Field() 可见, 这里定义了几个参数, 分别是:\nname: 小说名 order: 章节序号 title: 章节标题 content: 章节内容 此时再回看 parse_content() 函数, 函数实例化了一个 BiqugeDlItem 类, 并将小说名, 章节序号, 章节标题以及爬取得到的章节内容存入了 item 中, 最终将存有单章节数据的 item 对象返回.\npipelines.py 打开 pipelines.py, 定义一个 BiqugeDlPipeline 类, 在类中重写 open_spider(self, spider), process_item(self, item, spider) 以及 close_spider(self, spider) 函数, 根据文档介绍:\nopen_spider(self, spider) 函数在爬虫启动时被调用 process_item(self, item, spider) 函数处理每一个返回的 item 对象 close_spider(self, spider) 函数在爬虫运行结束后调用 结合以上特点, 我们可以在 pipielines.py 中实现对包含小说名, 章节序号, 章节标题, 章节内容的 item 的处理, 代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class BiqugeDlPipeline: def open_spider(self, spider): self.items = [] def process_item(self, item, spider): self.items.append(item) return item def close_spider(self, spider): self.items.sort(key=lambda i: i[\u0026#39;order\u0026#39;]) for item in self.items: # print(item[\u0026#39;title\u0026#39;]) with open(\u0026#39;downloads/{}.txt\u0026#39;.format(item[\u0026#39;name\u0026#39;]), \u0026#39;a\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(\u0026#39;\\n{}\\n\u0026#39;.format(item[\u0026#39;title\u0026#39;])) for content in item[\u0026#39;content\u0026#39;]: f.write(content.strip()) 在 open_spider() 中, 先定义一个空列表, 用于存储各个 item, 在 process_item() 中, 将传入的 item 添加至 items 列表中, 在 close_spider() 中, 对 items 列表进行排序操作, 然后将列表中内容写入最终文件, 实现了小说的按序存储. 至此, 整个爬取流程结束.\n运行爬虫 调试完成后, 在命令行启动爬虫, 测试爬取效果:\n1 $ scrapy crawl fiction_spider -a url=https://www.biduoxs.com/biquge/79_79244/ 总结 由于疫情管控在家荒废了一段时间, 不过好在还算有一点残存的自制力, 努力学习了一点东西, 这篇博客应该算是手敲的最长的一篇了, 虽然花的时间长了一点, 但是总归是学到了一些, 特别是结合源码和文档来边总结边学习, 能够领会到一些新知识. 这是对着例程敲代码所比较难学到的.\n","date":"2022-05-17T14:13:36Z","permalink":"https://cgcel.github.io/posts/2022/05/17/scrapy%E5%88%9D%E4%B8%8A%E6%89%8B-%E7%88%AC%E5%8F%96%E5%B0%8F%E8%AF%B4%E8%AE%B0%E5%BD%95/scrapy%E5%88%9D%E4%B8%8A%E6%89%8B-%E7%88%AC%E5%8F%96%E5%B0%8F%E8%AF%B4%E8%AE%B0%E5%BD%95/","title":"Scrapy初上手: 爬取小说记录"},{"content":"开头 之前给8T刷了 Derpfest, 也是基于A12 AOSP的一个ROM, 但是开发者在群里说已经不再维护, 前几天休息在家无聊逛了一下xda, 发现这个包点击量挺高, 于是决定给8T换一个ROM.\n准备 翻看 xda 的 ROM 发布帖子, 刷入步骤挺简单, 没有什么花里胡哨的, 把包下好之后就可以直接开整, 因为我的机已经解锁了, 也省去了很多繁琐的步骤.\nDownload recovery.img in download link Reboot phone to bootloader Open any terminal like cmd etc, enter \u0026ldquo;fastboot flash recovery recovery.img\u0026rdquo; Reboot phone to recovery and enter sideload mode Enter \u0026ldquo;adb sideload xxx\u0026rdquo; (xxx means the filename of rom zip you downloaded) Do factory reset in recovery (Mandatory for first time flash) Reboot You can also use rom installer to flash the way you did before.\nFor root: Download Magisk apk Rename it to xxx.zip Reboot to recovery and enter sideload mode Enter \u0026ldquo;adb sideload xxx.zip\u0026rdquo; (xxx means magisk file name) You can also patch boot.img and flash via fastboot.\n步骤 下载 ROM.zip 以及 recovery.img, 考虑到后续的 #root 操作, 还下载了最新的 Magisk-v24.3. 重启至 bootloader 并开始刷机.\n1 2 3 4 5 adb devices adb reboot bootloader fastboot devices fastboot flash recovery recovery.img fastboot reboot recovery 在 recovery 中点击 adb sideload, 然后进行以下操作:\n1 2 adb devices adb sideload ROM.zip 完成后, 重启进入系统.\n3. (Optional) Root 操作: 开机状态下, 通过 adb 指令进入 recovery 并打开 adb sideload, 然后进行以下操作: shell adb devices adb sideload Magisk.img 刷写完毕后, 重启进入系统, 安装 magisk.apk 即可查看 root 状态. 截图 重启进入系统, 几天使用体验下来还比较稳定, 当然也可能是现在只能来当作游戏机的原因, Magisk 模块也没有刷, app 里的模块商店没有内容, 我有一段时间没刷机了, 不知道是因为什么, 从什么时候开始的.\n摆弄了一下 Android 12 的小组件, 感觉还是挺好看的, 就是浪费屏幕空间.\n","date":"2022-04-13T16:32:51+08:00","permalink":"https://cgcel.github.io/posts/2022/04/13/%E4%B8%80%E5%8A%A08t%E5%88%B7nameless-aosp%E8%AE%B0%E5%BD%95/%E4%B8%80%E5%8A%A08t%E5%88%B7nameless-aosp%E8%AE%B0%E5%BD%95/","title":"一加8T刷Nameless AOSP记录"},{"content":"起因 由于前一段时间换了 iPhone, 导致原本把音乐文件存在本地听歌的白嫖习惯中断了, 使用 iTunes 实在是不方便 (需要固定一台 pc 管理本地音乐文件), 加之不想用 iCloud 服务, 因此我在 tg 上用缓存听了一个多月的歌\u0026hellip;\n树莓派放在东莞家里, 一直跑着 qbittorrent-nox 以及 frps 服务, 这两个都是日常使用很频繁的服务, 树莓派跑起来也是绰绰有余. 最近由于东莞疫情, 已经很久没有回去, 于是正好在休息日折腾一下很久没管的树莓派, 给树莓派装上 nextcloud, 用来当作自己的网盘, 把音乐文件存入, 方便手机同步.\n安装过程 安装apache2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 1.安装命令 sudo apt-get install apache2 # 2.启动apache2 systemctl start apache2 # 3.设置apache2开机自启 systemctl enable apache2 # 附上其他命令 # 查看运行状态 systemctl status apache2 # 重启 systemctl restart apache2 # 停止 systemctl stop apache2 安装php 1 2 3 4 5 # 1.安装php sudo apt-get install php libapache2-mod-php -y # 2.安装其他组件 sudo apt-get -y install php-fpm php-cli php-json php-curl php-imap php-gd php-mysql php-xml php-zip php-intl php-imagick php-mbstring -y 安装mariadb 1 2 3 4 5 6 7 8 9 10 11 12 # 1.安装 sudo apt-get install mariadb-server -y # 2.开启远程登陆权限 # 2.1 切换目录 d /etc/mysql/mariadb.conf.d # 2.2 找到修改权限的文件 grep -rn \u0026#34;skip-networking\u0026#34; * # 显示如下：在50-server.cnf文件的第26行 50-server.cnf:26:# Instead of skip-networking the default is now to listen only on # 2.3 编辑文件，注释掉 bind-address = 127.0.0.1 sudo nano 50-server.cnf 创建数据库用户以及添加数据库\n1 2 3 4 5 6 7 8 9 10 11 12 # 直接回车 不需要输入密码 mysql -uroot -p # account可替换成自定义的用户名，password可替换成自定义的密码 create database nextcloud; CREATE USER \u0026#39;account\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; GRANT ALL PRIVILEGES ON *.* TO \u0026#39;oc_admin\u0026#39;@\u0026#39;%\u0026#39; WITH GRANT OPTION; flush privileges; CREATE USER \u0026#39;account\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; GRANT ALL PRIVILEGES ON *.* TO \u0026#39;account\u0026#39;@\u0026#39;localhost\u0026#39; WITH GRANT OPTION; flush privileges; 安装nextcloud 从官网下载 .tar.bz2 的压缩包\n下载完成后, 需要上传到树莓派的 /var/www/html/ 目录下. 然后执行以下命令.\n1 2 3 4 5 6 7 8 9 10 # 1.解压文件 tar jxf nextcloud-21.0.0.tar.bz2 # 2.添加data目录和授权 chown -R root:root nextcloud # 3.进入nextcloud文件夹 cd nextcloud # 4.创建数据文件夹 mkdir data # 5.添加权限和授权 chown -R www-data:www-data data config apps (可选) 如果是在非root权限下操作, 可以先上传至树莓派, 剪切到 /var/www/html/ 目录后再进行解压.\n初始化nextcloud 准备 初始化前, 由于我的树莓派开启了ufw, 所以先开启防火墙端口白名单:\n1 sudo ufw allow 80/tcp 由于我的树莓派挂载一个1TB的移动硬盘, 为了充分利用以及避免后续操作, 先设置好硬盘开机自动挂载. 首先在命令行中输入:\n1 df -a 可以看到, 图中我已经对1TB的移动硬盘 /dev/sda1 进行了挂载, 挂载目录为事先创建好的目录 /mnt/usb-1.\n接着, 命令行输入以下指令, 查看移动硬盘格式:\n1 sudo fdisk -l 从上图可以看出, 我的移动硬盘为NTFS格式, 接下来寻找或者创建一个自己想要挂载的目录, 然后编辑 /etc/fstab, 在文件中添加以下内容:\n1 /dev/sda1 /mnt/usb-1 ntfs defaults 0 0 保存退出后, 命令行输入 sudo mount -a, 挂载后, 输入 df -a 查看是否成功挂载.\n(可选) 通过域名访问 由于之前找电信要了公网ip, 树莓派动态绑定了阿里云域名, 这里通过添加路由器虚拟服务器, 如下图所示, 外部端口选择自己想要映射的端口, 内部服务器IP填写树莓派在家中局域网的IP, 启用后便可在公网通过 域名:外部端口/nextcloud 的方式访问nextcloud页面.\n初始化 在完成了上述准备后, 便可以进行nextcloud的初始化. 在局域网中访问 树莓派IP:80/nextcloud 或在公网中访问 域名:外部端口/nextcloud 即可.\n在初始化页面中, 根据实际情况填写相关输入框:\nNTFS挂载的一些问题 由于挂载格式是NTFS, 导致初始化完成后, 页面显示 您的数据目录可被其他用户读取, 请更改权限为0770以避免其他用户查看目录, 经查询, 可以修改nextcloud目录下的 config/config.php 来解决, 按照我的安装目录, 定位至 /var/www/html/nextcloud/config , 编辑 config.php, 在文件中添加以下内容:\n1 \u0026#39;check_data_directory_permissions\u0026#39; =\u0026gt; false, 保存关闭后, 刷新nextcloud页面, 问题解决.\n使用 上传音乐文件 在PC端, 将本地音乐文件上传至nextcloud.\n并将存放音乐的nextcloud文件夹添加至本地.\n移动端使用 在手机端下载evermusic, 通过webdev连接nextcloud, 注意url一栏填写: xxx:port/nextcloud/remote.php/webdev, 其他的按照个人设置填写.\n连接上nextcloud后, 即可随心所欲听歌, 也可以选择将歌曲下载至本机.\nPC端 在设置同步的文件夹中, 使用 PotPlayer 打开所有文件\n结尾 经过一番折腾, 终于比较优雅地实现了把音乐文件存到iPhone的功能, 坚持恢复这种方式来听歌的起因也很简单, 那就是网易云时不时就下架我歌单的歌, 因此戒掉网易云, QQ也是理所当然的.\n参考内容 https://cynosure.online/2021/08/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BANextcloud%E7%A7%81%E6%9C%89%E4%BA%91 https://its401.com/article/jdyanghang/102828553 ","date":"2022-03-21T21:54:49+08:00","permalink":"https://cgcel.github.io/posts/2022/03/21/%E6%A0%91%E8%8E%93%E6%B4%BE4%E5%AE%89%E8%A3%85nextcloud%E8%AE%B0%E5%BD%95/%E6%A0%91%E8%8E%93%E6%B4%BE4%E5%AE%89%E8%A3%85nextcloud%E8%AE%B0%E5%BD%95/","title":"树莓派4安装nextcloud记录 (非docker安装法)"},{"content":"前言 在试用了一天多 ColorOS 之后, 鉴于其后台管理过于严格, 我又趁午休时间刷回了 OOS, 之前已经有了用 TWRP 保留 root 的全量包更新经验和文章, 本篇只想快速记录一下.\n准备工作 9008 线刷包 (OOS) payload_dumper Magisk-v23.0.apk 步骤 步骤一: 刷回 OOS 进入 开发者选项, 勾选 允许 OEM 解锁, 开启 USB 调试, 然后关机静置. 同时按住 音量+ 和 音量-, 然后用 USB 线连接电脑, 开启 9008 线刷, 刷机完毕后重启进入系统. 步骤二: 解锁 OOS 并 ROOT 进入 开发者选项, 勾选 允许 OEM 解锁, 开启 USB 调试, 然后输入以下指令:\n1 2 3 4 adb devices adb reboot bootloader fastboot devices fastboot oem unlock 使用 \u0026ldquo;音量键\u0026rdquo; 和 \u0026ldquo;电源键\u0026rdquo; 确定解锁手机, 然后完成初始化进入系统.\nroot步骤参考上一篇文章, 此处省略.\n步骤三: 更新系统 下载要更新的全量包, 复制多一份至电脑或手机 (取决你从哪一端下载)\n在电脑端, 使用 payload_dumper 提取 OOS.zip 的 boot.img, 并将其复制到手机存储中.\n安装并打开 Magisk, 选择 \u0026ldquo;安装\u0026rdquo;, \u0026ldquo;选择并修补一个文件\u0026rdquo;, 选择置入手机的 \u0026ldquo;boot.img\u0026rdquo;, 最后点 \u0026ldquo;开始\u0026rdquo;, Magisk 会生成一个类似于 magisk_patched-xxx.img 的文件, 将其复制一份到电脑:\n安装系统更新, 安装完毕后重启进入系统桌面:\n检查 root 权限, 发现此时是没有 root 的:\n刷入 magisk_patched-xxx.img, 根据以下指令完成:\n1 2 3 4 adb devices adb reboot bootloader fastboot devices fastboot flash boot magisk_patched-xxx.img 刷入完成后, 重启进入系统, 打开 \u0026ldquo;设置\u0026rdquo; 以及 \u0026ldquo;Magisk Manager\u0026rdquo; 查看系统信息以及 root 情况:\n结尾 至此, 成功尝试了 OOS 的全量包更新并保持 ROOT 权限, 之前是依靠 TWRP 以及 Magisk 中的模块自动化完成的, 这次全部自己操作, 还是积累到一点经验的.\n","date":"2021-05-22T00:00:00Z","permalink":"https://cgcel.github.io/posts/2021/05/22/%E4%B8%80%E5%8A%A08t%E5%85%A8%E9%87%8F%E5%8C%85%E5%8D%87%E7%BA%A7%E5%B9%B6%E4%BF%9D%E7%95%99root/%E4%B8%80%E5%8A%A08t%E5%85%A8%E9%87%8F%E5%8C%85%E5%8D%87%E7%BA%A7%E5%B9%B6%E4%BF%9D%E7%95%99root/","title":"一加8T全量包升级并保留ROOT"},{"content":"前言 距离一加 8T 的发布已经过去了大半年, 据说一加 8T 的 ColorOS 会在6月底释出, 大家都说大氢亡了🥴, 但是我不用氢啊🤡, 加上氧最近也用的有些腻了, 正好前一段时间关注到 8T 的 xda 论坛 挺活跃的, 已经有不少的 ROM 可以刷了:\n于是我就打算利用空闲时间刷一刷手里的 8T 解解馋, 玩累了正好回 ColorOS (如果一加不鸽的话\u0026hellip;)\n本篇将分为两大部分来记录, 分别是:\nOOS 刷 LOS 的记录 LOS 刷回 OOS 并 root 的记录 OOS 刷 LOS 准备 在准备刷机前, 我们需要 备份好数据, 并安装或下载好以下内容 (下载包以本篇博客日期为准, 如参考则需尽量下载最新包):\nadb (基本操作了, 没有adb就无法通过指令控制手机) 9008救砖包 (随时准备好救砖) lineage-18.1-20210513-nightly-kebab-signed.zip lineage-18.1-20210513-recovery-kebab.img copy-partitions-20210323_1922.zip GAPPS Magisk-v23.0.apk 具体步骤 详细刷机步骤参考 官方文档 , 下面我将按照具体指令来总结, 这样比较明了, 不用看详细的文字解释:\n进入 开发者选项 并开启 OEM 解锁 以及 USB调试\n检测 adb 连接情况后进入 bootloader, 然后解锁手机:\n1 2 3 4 adb devices adb reboot bootloader fastboot devices fastboot oem unlock 通过音量键和电源键, 将手机解锁, 手机将清除所有数据, 完成初始化后, 继续进入 开发者选项 并开启 OEM 解锁 以及 USB调试\n重启至 bootloader, 刷入 recovery:\n1 2 3 4 5 adb devices adb reboot bootloader fastboot devices fastboot flash recovery lineage-18.1-20210513-recovery-kebab.img fastboot reboot recovery 在 recovery 中, 将 A分区数据复制到 B分区, 避免B分区固件太久导致黑砖, 点击 \u0026ldquo;Apply Update\u0026rdquo;, 然后点击 \u0026ldquo;Apply from ADB\u0026rdquo;:\n1 adb sideload copy-partitions-20210323_1922.zip 签名验证失败的话, 点击 \u0026ldquo;Yes\u0026rdquo; 继续刷入即可.\n点击 \u0026ldquo;Advanced\u0026rdquo;, 然后点击 \u0026ldquo;Reboot to recovery\u0026rdquo;\n在 recovery 主界面 点击 \u0026ldquo;Factory Reset\u0026rdquo; 双清 (不能漏这一步, 某则脏刷将导致各种问题, 我第一次刷忘记双清, 直接 boot loop 加定位失灵), 然后点击 \u0026ldquo;Apply Update\u0026rdquo;, 点击 \u0026ldquo;Apply from ADB\u0026rdquo; 进入 adb sideload 模式刷入 LineageOS:\n1 adb sideload lineage-18.1-20210513-nightly-kebab-signed.zip 签名验证失败的话, 点击 \u0026ldquo;Yes\u0026rdquo; 继续刷入即可.\n(可选操作): 刷入额外的包, 如 GAPPS, Magisk等:\n如果要刷 GAPPS, 需要在重启进入系统前将其刷入, 其他包则可以在通过系统初始化后重启至 recovery 再刷.\n下面将以本次刷机为例, 记录刷入 GAPPS 和 Magisk 的过程:\n重启至 recovery, 然后进入 sideload 模式:\n1 adb sideload MindTheGapps-11.0.0-arm64-20210412_124247.zip 在 recovery 主菜单点击 \u0026ldquo;Reboot system now\u0026rdquo;, 即可开机进入系统, 完成初始化后检查谷歌全家桶能否正常运行, 无误后继续以下步骤:\n1 2 adb install Magisk-v23.0.apk adb reboot recovery 重启至 recovery 后, 进入 sideload 模式, 同时将电脑中的 Magisk-v23.0.apk 复制一份, 改名为 Magisk-v23.0.zip:\n1 adb sideload Magisk-v23.0.zip 在 recovery 主菜单点击 \u0026ldquo;Reboot system now\u0026rdquo;, 即可开机进入系统.\n发现的问题 刷 LOS 的过程中发现了两个问题, 问题和解决方法如下:\n定位不正常\n第一次刷入时忘记双清, 开机直接 boot loop, 解决后进入系统, 第二天上班时差点钉钉打卡无法定位\u0026hellip;\n解决方法: 刷入 LOS 前双清, 切忌 dirty flash.\n移动网络网速不正常\n第二次刷入时一切正常, 但切换至移动网络时网速只有 200+k/s, 明显不是5G该有的网速, 后到lineage的 reddit 论坛中发现有人有 同样的情况, 只需根据运营商修改 APN 即可. 刷回 OOS 后, 我进入设置对默认 APN 进行了截图 (此处以联通为例).\n解决方法: 刷入 LOS 后进入设置, 按照截图修改参数即可.\n截图 正常使用后的一些截图如下:\n修改 APN 后的 speedtest:\n更新界面:\nMagisk 界面:\nLOS 回 OOS 并 ROOT 准备 adb (基本操作了, 没有adb就无法通过指令控制手机) 9008救砖包 (随时准备好救砖) Magisk-v23.0.apk OOS全量包 (这里用的是 OOS Open Beta 4) Payload Dumper for Win 具体步骤 以下步骤以 LOS 刷至 OOS 为例, 刷机前记得 做好备份.\n参考视频: https://www.youtube.com/watch?v=zKd_mO7f1eM\n关机, 静置手机待其完全关闭, 电脑解压并打开下载好的 救砖包, 打开 MsmDownloadTool V4.0.exe, 选择 Other并下一步, target 项选择 O2, 表示刷入 OOS.\n同时按下手机的 音量+ 和 音量-, 插入 USB 线与电脑连接, 待出现 COM 口后, 点击 start, 看到开始加载进度条后方可松开音量键, 等待刷机完毕后, 手机将清除所有数据并自动重启.\n完成初始化后进入系统, 打开 开发者选项 并勾选 OEM 解锁 以及 USB 调试.\n解锁手机:\n1 2 3 4 adb decices adb reboot bootloader fastboot devices fastboot oem unlock 通过音量键和电源键确认解锁手机, 然后完成初始化进入系统.\n将下载好的 OOS Open Beta 4 全量包放入手机根目录, 进入设置, 系统升级, 选择 从本地更新, 然后选择根目录中的全量包进行 full update, 安装完毕后重启手机.\n在电脑端, 将下载好的 OOS 全量包中的 payload.bin 置入 \u0026ldquo;/payload_dumper-win64\u0026rdquo; 的 \u0026ldquo;/input\u0026rdquo; 文件夹中, 运行 payload_dumper.exe, 运行完毕后, 在 \u0026ldquo;/output\u0026rdquo; 中找到 boot.img 并复制到手机目录中, 如 \u0026ldquo;/Download\u0026rdquo; 中.\n安装并打开 \u0026ldquo;Magisk Manager\u0026rdquo;, 在首页点击 \u0026ldquo;安装\u0026rdquo;, 选择 \u0026ldquo;选择并修补一个文件\u0026rdquo;, 选择 \u0026ldquo;/Download/boot.img\u0026rdquo; 后点击 \u0026ldquo;开始\u0026rdquo;, Magisk Manager 将生成一个命名类似 magisk_patch.img 的文件在 \u0026ldquo;/Download\u0026rdquo; 中, 将其复制进电脑.\n将手机连接至电脑, 输入以下指令:\n1 2 3 4 adb devices adb reboot bootloader fastboot devices fastboot flash boot magisk_patch.img 刷入完毕后重启至系统, 打开 Magisk Manager 检查 root 状态.\n结尾 Root 之后, 又可以玩回很多以前的东西了, 比如把字体改成 Ubuntu 格式, 启用黑域, Swift Backup, Quick Switch等等, 倒是最近的 Xposed 框架又有新的 LSPosed, 简称 \u0026ldquo;LSP\u0026rdquo;, 是个轻量级的框架, 模块商店的模块还很少, 但是装个 WX 模块还是绰绰有余的.\n再说到动画方面, LOS 的动画流畅度简直吊打 OOS 的, 就比如点开微信信息推送和横屏返回桌面的动画, 一经比较便高下立判, OOS 小修小补这么久, 这个导航栏手势改得真是没眼看\u0026hellip;\n当然, 稳定性方面 OOS 肯定是 LOS 比不了的, 毕竟 LOS 只是一个个人维护的第三方 ROM, 没记错的话开发者 Luk1337 已经从一加6一路维护到一加8T了, 不愧是大佬👍\n","date":"2021-05-17T13:45:02+08:00","permalink":"https://cgcel.github.io/posts/2021/05/17/%E4%BB%8Eoos%E5%88%B0los--%E4%B8%80%E5%8A%A08t%E7%9A%84%E5%88%B7%E6%9C%BA%E8%AE%B0%E5%BD%95/%E4%BB%8Eoos%E5%88%B0los--%E4%B8%80%E5%8A%A08t%E7%9A%84%E5%88%B7%E6%9C%BA%E8%AE%B0%E5%BD%95/","title":"从OOS到LOS -- 一加8T的刷机记录"},{"content":"起因 ZeroTier 我从去年开始第一次使用, 用来给家里的树莓派做内网穿透, 不过中间因为3B当做个小服务器没什么好玩的就中断了.\n去年年底双十一从闲鱼如了一台 4G RAM 的4B (有点后悔没耐心等 8G 版本), 刷了 RaspiOS 之后就拿来跑PT站的签到脚本和当做下载机使用, 顺便安装了 ZeroTier One, 加入我的 ZeroTier Network, 如此一来在外也能较为轻松地访问到我的 pi.\n但是由于 ZeroTier 的官网在国内访问较慢, 每次需要通过新加入成员或者管理成员都要花一点时间登录官网并管理, 一开始还不觉得麻烦, 后来加入成员越来越多, 也邀请朋友一起加入, 这样管理起来就比较麻烦. 恰巧此时从 ZeroTier 官网上看到他们有官方的 API 可供用户调用, 于是我申请了 API Key, 短暂测试之后决定写一个 Telegram Bot 帮助监控以及管理我的 ZeroTier Network.\nAPI 调用测试 根据 官方文档 说明, 使用 postman 进行 API 调用测试, 根据指示, 在 header 中按照格式加入 API Key 即可请求到数据, 如下图:\nBot 设计 本 bot 使用 Telegram Bot 的第三方库 pyTelegramBotAPI 来实现, 代码部分主要包括两个部分:\nBot 命令以及定时任务 ZeroTier API 调用 初期版本 初期的版本通过在 config.yaml 文件中添加用户 ID 来添加管理员, 并通过私聊 bot 的方式来对 Network 进行管理. 这种交互方式在 只有一个管理员的时候还是挺方便的, 只需要直接与 bot 私聊发送指令, 开发到一大半的时候发现一个比较难实现的功能: 当有多个管理员管理的时候, bot 显示管理信息会比较困难 (需要在所有管理员对话框同步修改信息, 以显示是哪位管理员进行了此项操作).\n改进版本 与其说初期版本功能的实现比较绕, 不如说是设计之初就考虑的不周到, 本 bot 想要设计成一个允许多人管理的 bot, 就不能以私聊的方式交互, 而是应该将 bot 添加至群聊中, 让群管理员有权限进行管理, 如此一来逻辑便清晰许多了.\nBot 功能 Show networks info Show network members info Set member name (Admin only) Authorize new member (Admin only) Unauthorize member (Admin only) Delete member (Admin only) Set sub admin (Invite your friends to group chat, set as admin and manage the network with you) 创建私人 ZeroTier Network 管理 Bot 具体步骤 开始 创建你的 ZeroTier Web API Token:\n点击链接创建 API Access Token.\n创建你的 Telegram Bot:\n发送指令给 @BotFather, 你可以复制以下内容发送至 @BotFather 以编辑你的 bot 指令:\n1 2 3 4 5 6 help - Show commands list. show_network - Show your zerotier networks. set_member_name - Set your member\u0026#39;s name by using this command. auth_member - Authorize a member. unauth_member - Unauthorize a member. delete_member - Delete a member. 拷贝仓库至本地:\n1 $ git clone https://github.com/koonchung/ZeroTierTelegramBot.git 安装依赖:\n1 $ pip3 install -r requirements.txt 编辑 config.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Fill with your telegram bot token # Create your bot by sending commands to @BotFather in Telegram bot_token: \u0026#34;your_bot_token\u0026#34; # Fill with your zerotier token # Get your own API Access Token at: https://my.zerotier.com/account zerotier_token: \u0026#34;your_zerotier_web_api_token\u0026#34; # Fill with telegram id which you want to set as admin admin_id: - your_telegram_id # Fill with refresh seconds, used to check new members refresh_seconds: 60 运行 Bot\n1 2 $ cd ZeroTierTelegramBot $ python3 zerotiertelegrambot 将 bot 邀请至自建群聊中, 发送 /start@your_bot 至群聊, 然后即可开始管理你的ZeroTier Networks.\n后台运行\n本菜鸟使用tmux在后台挂起bot服务.\n运行截图 start\u0026amp;help\nshow_network\nnetwork_info\naccept\u0026amp;setname\nauth\u0026amp;setname\nnew_member\n结尾 项目已发布在 GitHub, 欢迎提意见🤗\n","date":"2021-05-13T21:51:24+08:00","permalink":"https://cgcel.github.io/posts/2021/05/13/%E6%88%91%E7%9A%84-zerotier-network-%E7%AE%A1%E7%90%86-bot/%E6%88%91%E7%9A%84-zerotier-network-%E7%AE%A1%E7%90%86-bot/","title":"我的 ZeroTier Network 管理 bot"},{"content":"开头 年初新冠疫情在武汉爆发, 感染者随着春运人流迅速扩散到全国各地, 彼时人人抢口罩, 甚至连药店的水银体温计都被洗劫一空. 那时每天都很关注自己的身体状况, 每天都需要健康上报以确保能正常回到工作岗位, 因此在淘宝下单了一个红外测温模块 MLX90614ESF-BAA, 用来自制一把测温枪, 及时量出体温. 但由于当时口罩, 测温枪等物资紧缺, 下单后过了很久客服通知说没货并给我退款, 这件事就不了了之.\n直到最近双十一没想到要买些什么东西的时候想起了这个未完成的小项目, 我在淘宝下单并顺利拿到了模块, 经过一番测试后将体温枪组装完毕.\n模块选型 整个项目用到的模块有:\nArduino Nano * 1 面包板 * 1 MLX90614ESF-BAA 红外测温传感器模块 * 1 按键模块 * 1 OLED 屏模块 * 1 这里面只有测温模块是第一次使用, 该模块可以测量 环境温度 以及 物体温度, 从店家介绍页面摘抄一些型号对照表:\n我选购的最便宜的型号 BAA 测量距离只有 2cm, 而 BCC 为 10cm, DCI 为 1m, 因此在实际测量中超出 2cm 测得的数据将会有明显误差.\n功能实现 按照以上选用的模块, 我按照下图将线路连接完毕:\n代码使用到的库文件如下:\nWire.h SPI.h Adafruit_GFX.h Adafruit_SSD1306.h Adafruit_MLX90614.h 其中 OLED 和测温模块都是通过 I2C 通信获取数据的, 而按键模块则只需通过检测引脚高低电平来判断是否按下并在代码中添加消抖语句即可.\n功能的实现比较简单, OLED 的坑在做毕设的时候已经踩完了, 现在基本上上手就能显示. 下面贴上完整代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include \u0026lt;Wire.h\u0026gt; #include \u0026lt;SPI.h\u0026gt; #include \u0026lt;Adafruit_GFX.h\u0026gt; #include \u0026lt;Adafruit_SSD1306.h\u0026gt; #include \u0026lt;Adafruit_MLX90614.h\u0026gt; #define SCREEN_WIDTH 128 // OLED display width, in pixels #define SCREEN_HEIGHT 64 // OLED display height, in pixels // Declaration for an SSD1306 display connected to I2C (SDA, SCL pins) #define OLED_RESET 4 // Reset pin # (or -1 if sharing Arduino reset pin) Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, \u0026amp;Wire, OLED_RESET); #define LOGO_HEIGHT 16 #define LOGO_WIDTH 16 Adafruit_MLX90614 mlx = Adafruit_MLX90614(); // constants won\u0026#39;t change. They\u0026#39;re used here to set pin numbers: // 按键引脚 const int buttonPin = 2; // 按键状态 int buttonState = 0; void setup() { // put your setup code here, to run once: // 初始化串口 Serial.begin(9600); // 初始化MLX90614 Serial.println(\u0026#34;Adafruit MLX90614 READY...\u0026#34;); mlx.begin(); // 初始化OLED模块 // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3D for 128x64 Serial.println(F(\u0026#34;SSD1306 allocation failed\u0026#34;)); for (;;); // Don\u0026#39;t proceed, loop forever } // Show initial display buffer contents on the screen -- // the library initializes this with an Adafruit splash screen. display.display(); delay(2000); // Pause for 2 seconds // Clear the buffer display.clearDisplay(); // 初始化完成后OLED打印信息 oled_print(\u0026#34;READY!\u0026#34;, 1000); // 设置按键引脚为输入 pinMode(buttonPin, INPUT); } void loop() { // put your main code here, to run repeatedly: // 获取按键状态 buttonState = digitalRead(buttonPin); // check if the pushbutton is pressed. If it is, the buttonState is HIGH: if (buttonState == HIGH) { delay(200); // 按键消抖 if (buttonState == HIGH) { // 串口打印环境温度以及物体温度 Serial.print(\u0026#34;Ambient = \u0026#34;); Serial.print(mlx.readAmbientTempC()); Serial.print(\u0026#34;*C\\tObject = \u0026#34;); Serial.print(mlx.readObjectTempC()); Serial.println(\u0026#34;*C\u0026#34;); String str = String(mlx.readObjectTempC()) + \u0026#34;*C\u0026#34;; // OLED打印物体温度 oled_print(str, 3000); } } } // 定义OLED打印函数, 参数为: 字符串, 显示时间 void oled_print(String str, int delay_time) { display.clearDisplay(); display.setTextSize(4); // Normal 1:1 pixel scale display.setTextColor(WHITE); // Draw white text display.setCursor(0, 0); // Start at top-left corner display.println(str); display.display(); delay(delay_time); display.clearDisplay(); display.display(); } 组装 组装的想法是收了快递之后看着快递盒突发奇想而来, 把东西简单准备好, 开局一把剪刀, 粘贴全靠热熔胶😎:\n制作过程完全没有技术含量, 最多就是剪了一些塑料泡沫填充空隙, 下面直接放成品图了:\n结尾 总算是把年初定的一个小项目完成了, 在家也算是有点事做了\u0026hellip; 这段时间在公司基本没有做什么项目, 都是在做文档, 写方案, 写标书之类的文案工作, 属实无聊.\n经过这次 DIY 我也想起年初还订了一个机械手拼装玩具, 上淘宝一看已经到货了, 于是补了尾款就等待它到货了, 今天下班路过文具店买了一块切割板, 一把美工刀和一把小剪刀, 期待到货之后的拼装.\n","date":"2020-11-17T00:00:00Z","permalink":"https://cgcel.github.io/posts/2020/11/17/diy%E9%A1%B9%E7%9B%AE--%E8%87%AA%E5%88%B6%E7%BA%A2%E5%A4%96%E6%B5%8B%E6%B8%A9%E6%9E%AA/diy%E9%A1%B9%E7%9B%AE--%E8%87%AA%E5%88%B6%E7%BA%A2%E5%A4%96%E6%B5%8B%E6%B8%A9%E6%9E%AA/","title":"DIY项目 -- 自制红外测温枪"},{"content":"前言 Android 11 正式版发布已经有一段时间, 前不久在 tg channel 上看到一加6即将适配Android 11 的消息:\n昨晚无聊刷一刷 xda, 发现一加6已经有第三方的A11包可以刷, 正好用晚上的时间试一试.\n准备 因为作者介绍此 ROM 时用红字表明要从Syberia OS Android 10 升级, 所以我先刷Syberia OS Android 10 后再升级 Android 11 版. (后来在文章下留言询问得知当作一个新 ROM 来刷也是 OK 的)\n下载清单 Android 10 部分 SyberiaOS ROM Downloads OOS 10.3.1 Downloads OpenGapps Downloads Latest TWRP Downloads xda 链接\nAndroid 11 部分 SyberiaOS ROM Download Flame Gapps Download (recommended) xda 链接\n操作步骤 我用作者描述的方法试了几次都刷不成功, 不是重启到rec就是卡在开机画面, 翻了一下评论区, 借用了一个网友的方法才成功, 为了看起来完整一点, 下面会一起列出所有步骤.\nConnect to PC and boot to bootloader 1 $ adb reboot bootloader Boot recovery 1 $ fastboot boot twrp.img Advanced wipe data and cache, format data, factory reset and reboot to bootloader Repeat step 1, 2, 3 Boot recovery Flash OOS, flash twrp, reboot to recovery Repeat step 6 Reboot to system, enable Developer Options and USB Debugging, reboot to recovery Flash Syberia OS Android 10, flash twrp, advanced wipe data and cache, reboot to recovery Flash gapps, reboot to system, enable Developer Options and USB Debugging, reboot to recovery Repeat step 9, 10 Flash Syberia OS Android 11, flash twrp, advanced wipe data and cache, reboot to recovery Flash gapps, reboot to system 总结 按照以上步骤来刷, 不出意外的话应该是可以成功的, 昨晚试了一晚上, 直到半夜十二点多才成功\u0026hellip; 这个 ROM 有毒\u0026hellip; 刷好之后对比了一下, 11 的变动看起来的确是挺少的, 只有轻微的一点点 UI 变化, 好像还有一些隐私的保护之类的.\n下面分享几张截图:\n最后, 虽然能预料到, 一加6 果然是比一加7 先有 Android 11 的包, 一加7 果然还是太弟弟了.\n","date":"2020-10-03T19:38:47+08:00","permalink":"https://cgcel.github.io/posts/2020/10/03/syberia-os-r-for-oneplus-6-%E5%88%B7%E6%9C%BA%E4%BD%93%E9%AA%8C/syberia-os-r-for-oneplus-6-%E5%88%B7%E6%9C%BA%E4%BD%93%E9%AA%8C/","title":"Syberia OS (R) for OnePlus 6 刷机体验"},{"content":"前言 最近长江沿岸发生了洪灾, 很多城市街道都被淹了, 在 大佬的指引 下, 我写了个脚本爬取长江水文网各个观测站的水位状况, 并绘图观察水位情况, 因为长江水文网 web 只提供实时数据, 没找到历史数据, 因此需要在服务器定时跑脚本爬数据并自己存起来.\n爬取数据 首先看一下长江水文网的首页, 我们能看到各站水位在一个显眼地方显示:\n这是一个不设防的网站, 所有实时水位数据都能在 http://www.cjh.com.cn/sqindex.html 请求到, 如图所示:\n可以看到json数据就在网页源码中, 我们只需要获取这部分字符串就可以得到所有实时数据.\n使用requests直接请求网页, 并对网页源码进行格式化以及截取:\n1 2 3 4 5 6 7 8 9 10 11 12 import requests url = \u0026#39;http://www.cjh.com.cn/sqindex.html\u0026#39; class CjhData(object): def __init__(self): pass def get_data(self): r = requests.get(url) result = r.text.split()[66][:-1] # 去除字符串最后的分号 return result 此时我们可以得到json字符串:\n1 2 3 4 \u0026#39;[{\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;39500\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60105400\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;寸滩\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;4\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;179.06\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;11600\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;乌 江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60803000\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;武隆\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;4\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;191.71\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;36300\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60107300\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;宜昌\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;5\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;50.41\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;33400\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60108300\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;沙市\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;6\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;41.88\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60111200\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;城陵矶(莲)\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;4\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;33.87\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;53100\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60112200\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;汉口\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;4\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;28.31\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;59700\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60113400\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;九江\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;4\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;22.17\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;76400\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60115000\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;大通\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;5\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;16.01\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;22800\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;洞庭湖\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;61512000\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;城陵矶(七)\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;4\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;33.99\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;13500\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;鄱阳湖\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;62601600\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;湖口\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;5\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;21.79\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60107000\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;茅坪(二)\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;5\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;161.36\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;34600\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;61000\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60106980\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;三峡水库\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;5\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;161.36\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;汉江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;61802500\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;龙王庙\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;6\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;160.78\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;1870\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;汉江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;61802700\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;丹江口水库\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;6\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;160.78\u0026#39;}]\u0026#39; 通过json库, 将其转成json对象就可以取其中的数据了.\n存储数据 爬取到实时数据后, 我们将数据存储在 mysql 中, 因为脚本会部署到树莓派4上, 所以树莓派上安装的是 mariadb, 这里先说明一下.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import pymysql class DB(object): def __init__(self): self.con = pymysql.connect(host=\u0026#39;localhost\u0026#39;, user=\u0026#39;root\u0026#39;, password=\u0026#39;password\u0026#39;, database=\u0026#39;yangtze_river_water_level\u0026#39;) self.cur = self.con.cursor() def insert_data(self, oq, q, rvnm, stcd, stnm, tm, wptn, z): # 检查某站某时间的数据是否已存储过, 避免重复存储数据 if self.cur.execute(\u0026#34;select * from water_level where stnm=%s and tm=%s\u0026#34;, (stnm, tm)) == 0: self.cur.execute(\u0026#34;insert into water_level(oq, q, rvnm, stcd, stnm, tm, wptn, z) values (%s, %s, %s, %s, %s, %s, %s, %s)\u0026#34;, (oq, q, rvnm, stcd, stnm, tm, wptn, z)) self.con.commit() else: pass def get_list_stnm(self): self.cur.execute(\u0026#34;select distinct stnm from water_level\u0026#34;) return self.cur.fetchall() def selectByStation(self, station): self.cur.execute(\u0026#34;select * from water_level where stnm=%s\u0026#34;, (station)) data = self.cur.fetchall() return data def delete_duplicate(self): pass def __del__(self): self.cur.close() self.con.close() 在主函数调用函数后, 将爬取到的数据存入数据库中:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import json from get_cjh_data import CjhData from database import DB def main(): cd = CjhData() # 实例化爬虫类 json_str = cd.get_data() # 得到json字符串 json_data = json.loads(json_str) # 将json字符串转成json对象 # print(json_data) db = DB() # 实例化数据库操作类 for item in json_data: # 将json对象中的数据遍历存入数据库中 db.insert_data(item[\u0026#39;oq\u0026#39;], item[\u0026#39;q\u0026#39;], item[\u0026#39;rvnm\u0026#39;], item[\u0026#39;stcd\u0026#39;], item[\u0026#39;stnm\u0026#39;], item[\u0026#39;tm\u0026#39;]/1000, item[\u0026#39;wptn\u0026#39;], item[\u0026#39;z\u0026#39;]) if __name__ == \u0026#39;__main__\u0026#39;: main() 运行成功后, 打开数据库检查结果:\n绘图 第一次使用python画图, 我简单学了一下网上的 matplotlib 的 demo, 修改一些参数就得到了自己想要的图 (这个折线图算是最基础的图形), 有一些小配置要写好, 比如更换字体来让中文得以显示等等:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import matplotlib.pyplot as plt from pylab import mpl import numpy as np import datetime from database import DB class DrawData(object): def __init__(self): self.db = DB() def draw(self): list_stnm = self.db.get_list_stnm() # 修改字体实现中文显示 mpl.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;Microsoft Yahei\u0026#39;] fig, ax = plt.subplots() ax.set_xlabel(\u0026#34;时间\u0026#34;) ax.set_ylabel(\u0026#34;水位\u0026#34;) ax.set_title(\u0026#34;长江沿岸水位统计\u0026#34;) for station in list_stnm: data = self.db.selectByStation(station) # print(data) list_tm = [] list_z =[] for item in data: timedata = datetime.datetime.fromtimestamp(item[6]) list_tm.append(timedata) list_z.append(float(item[8])) ax.plot(list_tm, list_z, label=station) ax.legend() fig.autofmt_xdate() plt.show() 运行脚本, 可以得到我们想要的折线图:\n2020-07-24 更新: 截至到编辑时间已经爬取到2666条数据😎, 波形图如下:\n部署 在树莓派上安装好所需依赖, 这里将mysql改为mariadb, 操作方法和mysql几乎一样, 因此建好database以及导入table后, 代码也能完美运行. 测试完毕后, 通过 crontab -e 添加定时任务就算基本完成了.\n","date":"2020-07-18T15:28:01+08:00","permalink":"https://cgcel.github.io/posts/2020/07/18/%E7%88%AC%E5%8F%96%E6%B4%AA%E7%81%BE%E6%9C%9F%E9%97%B4%E9%95%BF%E6%B1%9F%E6%B2%BF%E5%B2%B8%E6%B0%B4%E4%BD%8D%E5%B9%B6%E7%BB%98%E5%9B%BE/%E7%88%AC%E5%8F%96%E6%B4%AA%E7%81%BE%E6%9C%9F%E9%97%B4%E9%95%BF%E6%B1%9F%E6%B2%BF%E5%B2%B8%E6%B0%B4%E4%BD%8D%E5%B9%B6%E7%BB%98%E5%9B%BE/","title":"爬取洪灾期间长江沿岸水位并绘图"},{"content":"起因 去年年底开始, 部门里统计每月运维分队保障情况的任务就落到了我们头上, 大家都不是很愿意去做, 毕竟是重复劳动, 没有什么意义, 在信息系统里查起来还比较麻烦, 数据要一个一个地对, 然后根据当月分队的排班情况算到每个分队的统计里, 并按照规则排名以及打分, 一般都是每个月23或者24号开始统计, 正好这个月我 21-24 号放假加调休, 心想终于躲过一劫的我居然在回到公司上班的第一天被通知由我来统计! 无奈之下我只好以最快的速度做完, 但是这样下去什么时候才是个头啊, 于是就萌生了自己造轮子的想法, 正好复习一下自学的 python 爬虫.\n尝试 requests 写些小爬虫的时候, 用 requests 是最方便的. 一般来说模拟登录成功的话也就成功了一半, 后续数据可以轻松获得. 但是信息系统的一些前端渲染的数据无法通过 requests 获得, 比如下面使用 BeautifulSoup 解析后没有数据:\n1 \u0026lt;span id=\u0026#34;lblCount\u0026#34; style=\u0026#34;color:#C00000;font-weight:bold;\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; selenium 于是我只能用 selenium 来写, 这也是我第一次全程用 selenium 实现功能的爬虫. selenium 的使用也非常简单, 思路就是使用 find_element_by_id() 和 find_element_by_xpath() 来操作浏览器点击或者输入信息, 将响应后的网页源码通过 BeautifulSoup 解析, 得到想要的数据, 如下:\n1 \u0026lt;span id=\u0026#34;lblCount\u0026#34; style=\u0026#34;color:#C00000;font-weight:bold;\u0026#34;\u0026gt;1\u0026lt;/span\u0026gt; 处理数据 有了数据之后还要解决一个问题, 也就是推出各个分队的排班, 以便将爬到的数据算到对应责任分队处, 我是用了建 dict 和 list 的方式, 将4天一周期的分队排班和时间段结合, 得出正确的排班, 同时也新建各种dict用于存放分队运行数据, 如延误行李数, 事前维修次数, 责任分区维修次数, 值班日志以及根据这些数据排序得到的分数等等.\n运行环境 Windows 7-10\n与本机 Chrome 版本对应的 chromedriver (项目中版本为 Chrome version 89)\n下载链接1 下载链接2 下载链接3 Microsoft Office 或其他\n工作原理 编译环境: Python 3.8.6 (64-bit) Visual Studio Code 安装依赖: selenium openpyxl bs4 pyyaml tqdm lxml 实现原理: 通过 selenium 调用 chromedriver 打开 chrome, 打开信息系统登录页面并模拟登录 登录成功后请求对应延误行李, 值班日志等页面, 使用 BeautifulSoup, re 爬取数据 对数据进行处理后, 使用 openpyxl 将数据写入 Excel 中 功能调试完成后将 chrome 设置为 headless browser, 优化使用体验 使用方法 打开 config.yaml, 按照指引修改 账号, 密码, 起始日期, 结束日期, 刷新间隔, 航站楼, 内外网访问模式, 运行模式, 其中 刷新间隔 可按需修改, 修改完保存配置 运行 main.exe 或 main.py 程序窗口将显示爬取进度, 运行完毕后, 统计结果 以及 分队排班表 以 Excel 格式保存在 \\output 目录中 后续 脚本我从 v1.0 开始记录, 在使用过程中一直有遇到新的bug, 导致统计数字有问题, 期间也是一直有维护, 修了几个bug, 直到最近更新到了 v2.6.3, 相信统计功能已经接近完美 (flag)\n不过也是多亏了同事一直有帮忙检验表格准确性, 这些 bug 才得以被修复, 如果是我自己用估计也不会发现.\n","date":"2020-07-06T21:43:54+08:00","permalink":"https://cgcel.github.io/posts/2020/07/06/%E6%9C%80%E8%BF%91%E5%BC%80%E7%9A%84%E4%B8%80%E4%B8%AA%E7%88%AC%E8%99%AB%E5%B0%8F%E5%9D%91/%E6%9C%80%E8%BF%91%E5%BC%80%E7%9A%84%E4%B8%80%E4%B8%AA%E7%88%AC%E8%99%AB%E5%B0%8F%E5%9D%91/","title":"最近开的一个爬虫小坑"},{"content":"前言 疫情原因, 机场已经冷清很久了. 但是项目都照常缓慢进行中, 趁这次机会我好好学习了一下STM32的一些基础知识和使用方法. 教程的话看的是正点原子的官网教程, 正点原子的资料应该算是国内STM32初学者入门必学的教程了吧, 听说还有野火的也不错, 网上很多例子都有他们家代码的影子.\n实际使用过程中, 我越来越能体会到Arduino的简便之处, 但是相对的对实现原理会不太在意, 在入门STM32的过程中, 我对一些单片机功能有了更深的了解, 就比如常用的串口功能.\n之前对Arduino的串口编程有过不少实践, 还整理过 [[2019-12-03-Arduino的主从机双向通信|Arduino之间的串口通信demo]], 本篇文章不对STM32单片机底层寄存器, 官方库文件进行过多解读, 只就Arduino与STM32的串口编程方面进行比较, 结合注释进行适当说明.\n硬件准备 STM32C8T6开发板 STM32RCT6开发板 正文 Arduino串口 首先回顾一下Arduino的串口函数, 可以看以下demo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 String inputString = \u0026#34;\u0026#34;; // a String to hold incoming data void setup() { // initialize serial: Serial.begin(9600); } void loop() { while(Serial.available()){ inputString += char(Serial.read()); delay(2); } // print the string when a newline arrives: if (inputString.length() \u0026gt; 0) { Serial.print(inputString); // clear the string: inputString = \u0026#34;\u0026#34;; } } Arduino语言中, 先对串口进行初始化, 然后只需要调用 Serial.available() 来判断串口是否接收到数据, 若串口有数据, 则Serial.available() 大于0且值为串口数据字节数. 接着, 通过循环, 使用 Serial.read() 将串口缓存的数据一字节一字节的存取到实现定义好的空字符串中, 如此便可得到Arduino串口接收到的完整数据.\nSTM32串口 接着结合正点原子的串口demo讲一下STM32的串口初始化以及接收数据, 打印数据的功能.\n串口初始化 STM32RCT6一共有3个硬串口, 以串口3为例, 在项目中导入 usart3.h, usart3.c.\n在 usart3.h 中, 我们定义了接收和发送数据长度, 定义了空字符串, 接收数据状态变量, 数据长度以及串口发送, 清空的函数.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #ifndef __USART3_H #define __USART3_H\t#include \u0026#34;sys.h\u0026#34; #define USART3_MAX_RECV_LEN\t600\t//最大接收缓存字节数 #define USART3_MAX_SEND_LEN\t600\t//最大发送缓存字节数 #define USART3_RX_EN 1\t//0,不接收;1,接收. extern char USART3_RX_BUF[USART3_MAX_RECV_LEN]; //接收缓冲,最大USART3_MAX_RECV_LEN字节 extern char USART3_TX_BUF[USART3_MAX_SEND_LEN]; //发送缓冲,最大USART3_MAX_SEND_LEN字节 extern vu16 USART3_RX_STA; //接收数据状态 extern int USART3_RX_BUF_LEN; //用于存放接收数据长度 void usart3_init(u32 bound);\t//串口2初始化 void u3_printf(char* fmt,...); void USART3_SendChar(char c); void USART3_SendString(char *s); void USART3_SendArray(u8 array[], int num); void USART3_ClearBuf(); //清空接收的串口数据 #endif 在 usart3.c 中, 我们对串口3进行初始化:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 void usart3_init(u32 bound) { NVIC_InitTypeDef NVIC_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); // GPIOB时钟 RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3,ENABLE); //串口3时钟使能 USART_DeInit(USART3); //复位串口3 //USART3_TX PB10 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; //PB10 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\t//复用推挽输出 GPIO_Init(GPIOB, \u0026amp;GPIO_InitStructure); //初始化PB10 //USART3_RX\tPB11 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //浮空输入 GPIO_Init(GPIOB, \u0026amp;GPIO_InitStructure); //初始化PB11 USART_InitStructure.USART_BaudRate = bound; //波特率一般设置为9600; USART_InitStructure.USART_WordLength = USART_WordLength_8b; //字长为8位数据格式 USART_InitStructure.USART_StopBits = USART_StopBits_1; //一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No; //无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; //无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\t//收发模式 USART_Init(USART3, \u0026amp;USART_InitStructure); //初始化串口\t3 USART_Cmd(USART3, ENABLE); //使能串口 //使能接收中断 USART_ITConfig(USART3, USART_IT_RXNE, ENABLE); //开启中断 //设置中断优先级 NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=2 ; //抢占优先级3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道使能 NVIC_Init(\u0026amp;NVIC_InitStructure);\t//根据指定的参数初始化VIC寄存器 TIM4_Int_Init(1000-1,7200-1); //10ms中断 USART3_RX_STA=0; //清零 TIM_Cmd(TIM4,DISABLE); //关闭定时器4 } 以上代码是对串口3的初始化, 这里不再赘述, 唯一有区别的地方是最后3句, 这里采用了定时器4设置的10ms定时, 在串口3接收到数据后开启定时器4, 每10ms读取一字节串口数据, 若10ms内没有收到数据, 则判定数据接收完毕, 此时将串口状态位置0, 表示串口3已经接受完数据, 并关闭定时器4.\n串口中断函数 在初始化中, 可以看到开启了串口中断, 接下来在 usart3.c 中对串口3中断函数进行编写, 代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void USART3_IRQHandler(void) { u8 res; if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET) //接收到数据 { res =USART_ReceiveData(USART3); if((USART3_RX_STA\u0026amp;(1\u0026lt;\u0026lt;15))==0) //接受未完成 { if(USART3_RX_STA\u0026lt;USART3_MAX_RECV_LEN-1) //判断长度, 小于设定长度则还可以接收数据 { TIM_SetCounter(TIM4,0); //计数器清空 if(USART3_RX_STA==0) //使能定时器4的中断 { TIM_Cmd(TIM4,ENABLE);//使能定时器4, 每10ms接受一帧串口数据 } USART3_RX_BUF[USART3_RX_STA++]=res;\t//记录接收到的值, 同时更新数据长度 USART3_RX_BUF_LEN = USART3_RX_STA; } else // 若数据长度超出定义长度则强行将STA最后一位置1 { USART3_RX_STA|=1\u0026lt;\u0026lt;15; //强制标记接收完成 //\tUSART3_ClearBuf(); } } } //当串口3数据与定义字符串相同则执行以下代码 if (strcmp(USART3_RX_BUF, \u0026#34;ping\u0026#34;) == 0){ u3_printf(\u0026#34;电机转速: %d\\r\\n温度: %.2f\\r\\n湿度: %.2f\\r\\n\u0026#34;, rate, temp, hum); } } 其中关于 USART3_RX_STA 的运算和条件判断语句我研究了很久, 长时间没有接触C了, 很多位运算都忘了, 加上单片机的寄存器的相关基础掌握得不够熟练, 导致在这一块的理解很慢.\n首先看一下在 usart3.c 中 USART3_RX_STA 的定义, 里面有正点原子和我额外加的注释:\n1 2 3 4 5 6 7 8 //通过判断接收连续2个字符之间的时间差不大于10ms来决定是不是一次连续的数据. //如果2个字符接收间隔超过10ms,则认为不是1次连续数据.也就是超过10ms没有接收到任何数据,则表示此次接收完毕. //接收到的数据状态 (USART3_RX_STA位数的值) //[15]:0,没有接收到数据;1,接收到了一批数据. //[14:0]:接收到的数据长度 //u16为unsigned short是16位, 占2字节 //该变量同时还记录接收到的数据长度 vu16 USART3_RX_STA=0; 引用正点原子在教程里的话: 这里我们设计了一个小小的接收协议：通过这个函数，配合一个数组 USART_RX_BUF[], 一个接收状态寄存器 USART_RX_STA (此寄存器其实就是一个全局变量, 由作者自行添加. 由于它起到类似寄存器的功能, 这里暂且称之为寄存器) 实现对串口数据的接收管理. USART_RX_BUF的大小由 USART_REC_LEN 定义, 也就是一次接收的数据最大不能超过 USART_REC_LEN 个字节. USART_RX_STA 是一个接收状态寄存器其各的定义如下表所示：\nUSART_RX_STA bit15 bit14 bit13~0 接收完成标志 接收到0x0D标志 接收到的有效数据个数 我们可以知道这个STA变量只用作是否接收完成的标志变量, 第15位为0表示没有接收完, 为1表示接收完成, 因此我们可以在获取串口数据的代码中加入对STA的判断, 比如如下代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int main(void) { u8 t; u16 times=0; delay_init(); //延时函数初始化 uart3_init(115200); //串口初始化为115200 while(1) { if(USART3_RX_STA\u0026amp;0x8000) //用于判断第15位是否为1, 若为0则计算结果为0, 代码不会执行 { u3_printf(USART3_RX_BUF); //打印字符串 u3_printf(\u0026#34;\\r\\n\u0026#34;); //插入换行 USART3_ClearBuf(); //清空串口缓存数据 USART_RX_STA=0; //调用完串口数据后对STA置0, 表示串口恢复接收状态 } } } 有些网上的demo是 USART3_RX_STA \u0026amp; (1\u0026lt;\u0026lt;15), 其实是一样的, 0x8000和1\u0026laquo;15换算成二进制都是‭1000 0000 0000 0000, 本质上都是对STA最后一位进行判断, 而在代码中强行将STA最后一位置1可以使用 USART3_RX_STA|=0x8000, 道理是一样的. ‬\n当然我们也可以对接收到的数据长度进行判断, 如果大于0则表示串口接收到数据, 将其打印出来即可, 至于串口是否已经接收完成, 在之前的初始化函数中可以看到事先定义并开启了定时器4, 它是用来判断规定时间内串口有没有接收到新数据的, 如果超出定义时间串口没有收到新数据, 则在代码中对状态位赋值表示已经接受完成, 这个方法是根据项目需求制定的, 对串口数据某几位进行校对来判断是否接收完成也完全是可以的.\n总结 通过对STM32的入门学习, 我对单片机的一些功能实现有了更深的了解, 不过这周进度也是慢下来了, 因为物资采购才刚刚上报, 要等模块来了我们才能继续下一步的调试, 接下来就暂时打算测试一下STM32通过TTL-RS485向串口服务器发送数据. 这篇东西居然断断续续写了几天, 今天放假第一天, 结果早上到下午两点多停电, 外面还有装修声, 这个假期体验真是一般\u0026hellip;🤯\n","date":"2020-06-03T16:47:33+08:00","permalink":"https://cgcel.github.io/posts/2020/06/03/stm32%E7%9A%84%E4%B8%B2%E5%8F%A3%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/stm32%E7%9A%84%E4%B8%B2%E5%8F%A3%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","title":"STM32的串口学习总结"},{"content":"写在前面 手上的一加7已经 root 了一个多月, 一加的更新迟迟不来, 安全补丁还停留在3月份的, 终于在今天 Oxygen Updater 推送了 OB13 更新, 于是我赶紧下下来, 尝试一下保留 root 状态的 OTA 升级.\n操作步骤 网上冲浪一下就可以找到很多教程, 不过多数是英文的, 因为一加在国内还不够主流. 总结一下基本步骤如下:\n下载全量包, 进入系统更新 - 选择本地安装, 安装完毕后不要重启 在 magisk manager 中安装 TWRP A/B Retention Script 打开 magisk manager, 卸载 - 还原原厂镜像, 卸载成功后不要重启 在 magisk manager 中, 点击安装 - 安装到未使用的槽位(OTA后) - 点击重启 注意重启后手机 (可能) 会重启两次, 不用进行其他操作, 等待其重启完成即可.\n具体操作 为了记录得详细一点, 我截了一些图, 下面将按照步骤贴出.\n1.下载/安装全量包 在 Oxygen Updater 中下载全量包.\n进入设置并选择本地安装, 一般全量包都会被下载至根目录.\n安装完毕后不要重启, 直接退出升级界面即可.\n2. 安装 TWRP A/B Retention Script 在magisk manager中下载安装 TWRP A/B Retention Script, 安装完成后返回magisk manager主界面.\n3. 卸载magisk 打开 magisk manager, 卸载 - 还原原厂镜像, 卸载成功后不要重启\n4. 安装magisk到另一个槽位 现在的安卓机都是 A/B 分区的, 系统的安装/更新是装至当前运行系统的另一个槽位中, 也就是未激活的槽位.\n在 magisk manager 中, 点击安装 - 安装到未使用的槽位(OTA后) - 点击重启\n5. 重启手机并检验 在 magisk manager 中点击重启后, 手机 (可能) 会执行两次重启, 此时不用担心变砖(狗头), 等他自己重启完成就行了.\n重启完成后, 我们可以看到系统已经更新至 OB13.\n然后随便下一个 app 检测一下手机是否保持了 root 状态.\n总结 学会这个方法之后, 以后如果还买一加就可以到手就 root 了 (如果还买的话), 真是美滋滋, 好了总结完毕.\n","date":"2020-05-07T15:02:04+08:00","permalink":"https://cgcel.github.io/posts/2020/05/07/%E4%B8%80%E5%8A%A07-ota%E5%8D%87%E7%BA%A7%E7%B3%BB%E7%BB%9F%E5%B9%B6%E4%BF%9D%E7%95%99root%E8%AE%B0%E5%BD%95/%E4%B8%80%E5%8A%A07-ota%E5%8D%87%E7%BA%A7%E7%B3%BB%E7%BB%9F%E5%B9%B6%E4%BF%9D%E7%95%99root%E8%AE%B0%E5%BD%95/","title":"一加7 OTA升级系统并保留root记录"},{"content":"前言 前一阵大佬给了块 RFID 读写模块让我们研究, 正好别人没有板子, 我就先一步拿着我的 nano 和 esp8266 去办公室玩玩了.\n什么是RFID? 简介 无线射频识别即射频识别技术（Radio Frequency Identification，RFID），是自动识别技术的一种，通过无线射频方式进行非接触双向数据通信，利用无线射频方式对记录媒体（电子标签或射频卡）进行读写，从而达到识别目标和数据交换的目的，其被认为是21世纪最具发展潜力的信息技术之一。\n无线射频识别技术通过无线电波不接触快速信息交换和存储技术，通过无线通信结合数据访问技术，然后连接数据库系统，加以实现非接触式的双向通信，从而达到了识别的目的，用于数据交换，串联起一个极其复杂的系统。在识别系统中，通过电磁波实现电子标签的读写与通信。根据通信距离，可分为近场和远场，为此读/写设备和电子标签之间的数据交换方式也对应地被分为负载调制和反向散射调制。\n工作原理 RFID技术的基本工作原理并不复杂：标签进入阅读器后，接收阅读器发出的射频信号，凭借感应电流所获得的能量发送出存储在芯片中的产品信息（Passive Tag，无源标签或被动标签），或者由标签主动发送某一频率的信号（Active Tag，有源标签或主动标签），阅读器读取信息并解码后，送至中央信息系统进行有关数据处理。\n一套完整的 RFID 系统， 是由阅读器与电子标签也就是所谓的应答器及应用软件系统三个部分所组成，其工作原理是阅读器（Reader）发射一特定频率的无线电波能量，用以驱动电路将内部的数据送出，此时 Reader 便依序接收解读数据， 送给应用程序做相应的处理。\n测试模块 手头上的模块是 JRD-100, 模块的测试非常顺利, 直接使用厂家提供的 GUI, 首先安装相应驱动, 接着通过 TTL 转 USB 将模块连接上电脑就可以进行 RFID 的读写操作了, 这里只尝试了读码功能, 测试无误后就开始软件方面的开发了. 而模块的操作方式也非常主流, 使用串口指令对其进行操作, 而返回的数据同样会通过串口与主板通信.\n开始编写Arduino库 基本结构 Arduino 的库文件其实就是 C++ 的一个类, 其中必须要引入 Arduino 核心类 Arduino.h, 否则无法在 Arduino 上使用. 其实在之前的使用过程中对 Arduino 库的结构已经有所了解, 基本上都是以下结构:\n1 2 3 4 5 6 -- JrdReader -- example -- xxx xxx.ino JrdReader.h rdReader.cpp 编译环境 在 Arduino IDE 中编写自定义库操作比较简单, 在新建好的 Arduino 项目中新建Tab并命名为 .h 以及 .cpp 文件即可, 如下图所示:\n建好之后的界面如下图所示, 然后就可以开始敲代码编译了.\n头文件与源文件 按照 C++ 语法创建头文件:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026#34;Arduino.h\u0026#34; #ifndef _JRDREADER_H__ #define _JRDREADER_H__ class JrdReader { private: public: JrdReader(); String readOnce(); }; #endif 在源文件中实现头文件的自定义方法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026#34;Arduino.h\u0026#34; #include \u0026#34;JrdReader.h\u0026#34; #include \u0026#34;HardwareSerial.h\u0026#34; /** * read once HEX command */ char read_once_cmd[7] = {0xBB, 0x00, 0x22, 0x00, 0x00, 0x22, 0x7E}; String comdata = \u0026#34;\u0026#34;; JrdReader::JrdReader() { } String JrdReader::readOnce() { String baggageCode = \u0026#34;\u0026#34;; String comstr = \u0026#34;\u0026#34;; // send read_once command Serial.write(read_once_cmd, 7); delay(50); while (Serial.available() \u0026gt; 0) { char data = Serial.read(); comdata += String(data, HEX); delay(50); } if (comdata.length() \u0026gt; 0) { Serial.print(\u0026#34;comdata: \u0026#34;); for (int i = 0; i \u0026lt; comdata.length(); i++) { comstr += String(comdata[i]); Serial.print(comdata[i]); } Serial.println(); } // clear comdata in order to accept another one. comdata = \u0026#34;\u0026#34;; // format comstr comstr.replace(\u0026#34;ffff\u0026#34;, \u0026#34;ss\u0026#34;); comstr.replace(\u0026#34;ff\u0026#34;, \u0026#34;\u0026#34;); comstr.replace(\u0026#34;ss\u0026#34;, \u0026#34;ff\u0026#34;); Serial.println(\u0026#34;comstr: \u0026#34; + comstr); if (comstr.length() \u0026gt; 13) { // read RFID code for (int i = 18; i \u0026lt; 28; i++) { baggageCode += comstr[i]; } } else { baggageCode = \u0026#34;读取错误 (Unable to read)\u0026#34;; } return baggageCode; } 由于手头上还有别的任务所以先实现了最简单的单次读码功能, 原理则是将说明书中提供的十六进制串口指令通过 Arduino 的 Serial 函数发送给 JRD-100 模块, 模块处理完毕后会将数据通过串口返回给 Arduino, 此时只需要通过串口接收新信息并按照一定规律格式化, 解析就可以得到想要的数据, 其中因为导入了 Arduino.h 这个核心库文件, 所以我们在开发 Arduino 库文件的时候可以调用一些 Arduino 的编程方法, 比如上方代码中的 Serial.write(), Serial.print() 等函数.\n加载库并使用 按照上述 基本结构 中的项目结构保存文件后, 将文件夹复制到 Arduino 的 libraries 文件夹中, 或者将文件夹打包成 .zip 格式, 然后在 Arduino IDE 中它通过 项目-加载库-添加.ZIP库 的方法添加, 然后最好重启一下 Arduino IDE, 此时就可以直接在新建的 .ino 文件中引入自定义的库文件了.\n后续计划 这个库可以写的方法远不止一个, 比如读取多次, 写码等方法, 后续应该会加上, 同时已经实现的 readOnce() 方法的读取率还有待提高, 估计与函数延时有一定关系, 需要慢慢调试得到最佳的数据接收间隔.\n编译环境的摸索 Arduino 的 IDE 由于没有代码补全以及文件管理而广受诟病, 于是我们可以通过很多第三方IDE结合插件来进行 Arduino 开发, 比较常用的有 VS code, sublime, code blocks等等, 我也同样都尝试过, 但是都遇到了各种各样的问题, 最终回到了官方的 IDE 进行开发, 只能说第三方的额插件虽然支持, 但是存在很多缺陷, 比如路径常常需要导入, 只支持到一些版本的 Arduino IDE 等等, 希望官方的编译器能够支持更多功能, 让开发变得简单吧.\n结尾 可能这是博客创建到现在最长的一篇了, 毕竟前面复制了一大段介绍🤓, 那么就先到此为止吧, 下面附上一些参考网址:\nhttps://baike.baidu.com/item/%E5%B0%84%E9%A2%91%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/9524139?fromtitle=RFID\u0026fromid=497249 https://www.arduino.cc/en/Hacking/libraryTutorial https://www.arduino.cc/en/Reference/APIStyleGuide ","date":"2020-04-26T19:37:43+08:00","permalink":"https://cgcel.github.io/posts/2020/04/26/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAarduino%E5%BA%93/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAarduino%E5%BA%93/","title":"我的第一个Arduino库"},{"content":"前言 在家中闲来无事, 想起了积灰已久的树莓派3B, 决定来捣鼓一番, 此前试过使用花生壳的免费内网穿透服务, 体验一般, 从舍友那听说可以用 frp 来实现, 于是准备试一试. frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。\n准备 首先准备好以下物品:\n树莓派3B PC 一台 VPS 一台 显示器 (用于树莓派初始化, 根据自己的情况可以使用别的方式) 配置过程 1. 初始化树莓派 首先在树莓派上安装系统, 我安装的是 Raspbian Buster with desktop, 将系统镜像刷写进SD卡后, 通过接入显示器的方式控制树莓派联网, 开启 SSH 以及 VNC , 这里详细过程就不记录, 算是玩树莓派的基本操作了. 然后我们找到树莓派的 IP, 然后使用 xshell 连接树莓派, 初始化树莓派的过程到此结束.\n2. 准备VPS 这次我租了 VirMach 的服务器, 最低配的 VPS 只需1.25刀/月, 应该是我用过的最便宜的 VPS 了, 不过 IP 处于被半 ban 的状态, 挂上代理才能在xshell上稳定连接.\n3. 配置frp frp 是 GitHub 上的开源项目, 可以直接到 https://github.com/fatedier/frp/releases 中下载, 这里, 根据 VPS 选择 frp_0.31.2_linux_amd64.tar.gz, 而树莓派则选择下载 frp_0.31.2_linux_arm.tar.gz. 根据对应的操作系统及架构, 从 Release 页面下载最新版本的程序, 将 frps 及 frps.ini 放到具有公网 IP 的机器上, 将 frpc 及 frpc.ini 放到处于内网环境的机器上. 而实际上每一个压缩包内都包含了这两个文件, 只需要根据机器的类型来进行配置并运行即可 (Server或者Client端).\n在VPS中, 解压压缩包, 编辑frps.ini文件, 按照配置说明, 可以简单进行编辑:\n1 2 3 # frps.ini [common] bind_port = 7000 启动frps.ini:\n1 ./frps -c ./frps.ini 在树莓派中, 解压压缩包, 假设 frps 所在服务器的公网 IP 为 x.x.x.x:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # frpc.ini [common] server_addr = x.x.x.x server_port = 7000 [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000 [VNC] type = tcp local_ip = 127.0.0.1 local_port = 5900 remote_port = 6500 启动frpc.ini:\n1 ./frpc -c ./frpc.ini 启动后, 内网穿透已经完成, 可以看见, 在树莓派中已经配置了ssh以及VNC访问, 其中5900是树莓派VNC的端口. 至此, 配置已经完成, 我们可以在ssh客户端通过x.x.x.x:6000以及在VNC客户端通过x.x.x.x:6500访问树莓派了!\n","date":"2020-03-11T21:00:15+08:00","permalink":"https://cgcel.github.io/posts/2020/03/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E8%AE%B0%E5%BD%95/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E8%AE%B0%E5%BD%95/","title":"树莓派使用Frp实现内网穿透记录"},{"content":"开篇 在上一篇博客 [[2020-02-08-ViewPager禁用滑动实践和总结|ViewPager禁用滑动实践和总结]] 中我总结了禁用 ViewPager 滑动的解决方案, 这也是网上示例的主流解决方法, 但是使用这个方法后, 导致项目中 Fragment 的 RecyclerView 与 ViewPager 的滑动出现冲突, 无法实现效果, 如下图:\n从上图可以看到按照上一篇博客中重写子 Fragment 中的 ViewPager 的 OnInterceptTouchEvent() 和 onTouchEvent() 后, 于子 Fragment 中显示的 RecyclerView 上滑动将无法使用 Activity 的 ViewPager 切换, 只能在 RecyclerView 没有覆盖到的边框位置进行滑动, 这样的操作无疑非常不舒适, 于是我只能继续在网上搜索相关解决方案, 现总结如下.\n修改步骤 与上一篇博客思路一样, 只需要重写 ViewPager 的 canScrollHorizontally() 函数即可, 代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class UnScrollableViewPager extends ViewPager { private boolean scrollable = false; public UnScrollableViewPager(Context context) { super(context); } public UnScrollableViewPager(Context context, AttributeSet attrs) { super(context, attrs); } @Override // 重写该函数, 用于判断是否能水平滑动 public boolean canScrollHorizontally(int direction) { return scrollable; // false表示已经到最右 } } 修改完代码后重新运行, 效果如下, 可见已经实现了预期的效果.\n参考链接: https://www.jianshu.com/p/01ad565a80b4 https://www.jianshu.com/p/ce347cf991db ","date":"2020-02-10T16:01:35+08:00","permalink":"https://cgcel.github.io/posts/2020/02/10/viewpager%E7%9A%84%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/viewpager%E7%9A%84%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","title":"ViewPager的嵌套滑动冲突问题解决"},{"content":"开篇 接触 Android 有一段时间了, 起因是帮同事一起做项目, 顺便自己学习, 于是项目一直断断续续进行, 很多控件和功能都是参考《第一行代码》还有网上的例子慢慢探索的, 最近一直在钻 TabLayout 的点击切换, 也就是禁用 ViewPager 的左右滑动切换的牛角尖, 具体效果如下图所示. 网上的例子实在是太千篇一律了, 导致有些地方只要其中一篇阅读量很多的博客没有, 其他转载或者借鉴的博客就都不会写🤪, 下面就记录一下我在原有 TabLayout\u0026amp;ViewPager 基础上修改的示例.\n实现步骤 1. 重写ViewPager 如果要实现禁用滑动的效果, 那么就需要重写 ViewPager, 因为默认是开启滑动的, 具体代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class NoScrollingViewPager extends ViewPager { private boolean scrollable = false; public NoScrollingViewPager(Context context) { super(context); } public NoScrollingViewPager(Context context, AttributeSet attrs) { super(context, attrs); } @Override // 重写以下两个TouchEvent, 返回false以禁用滑动动作的监听 public boolean onInterceptTouchEvent(MotionEvent ev) { return scrollable; } @Override public boolean onTouchEvent(MotionEvent ev) { return scrollable; } } 以上重写代码都是千篇一律的, 只需要重写两个函数.\n2. 修改对应xml文件 接下来到对应xml修改原来的 ViewPager 为自定义的 NoScrollingViewPger 组件, 代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;android.support.design.widget.TabLayout android:id=\u0026#34;@+id/tab_fragment1\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt;\u0026lt;/android.support.design.widget.TabLayout\u0026gt; \u0026lt;!--\u0026lt;android.support.v4.view.ViewPager--\u0026gt; \u0026lt;!--android:id=\u0026#34;@+id/viewpager_fragment1\u0026#34;--\u0026gt; \u0026lt;!--android:layout_width=\u0026#34;match_parent\u0026#34;--\u0026gt; \u0026lt;!--android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt;\u0026lt;/android.support.v4.view.ViewPager\u0026gt;--\u0026gt; \u0026lt;com.elvin.tablayouttest.NoScrollingViewPager android:id=\u0026#34;@+id/viewpager_fragment1\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt;\u0026lt;/com.elvin.tablayouttest.NoScrollingViewPager\u0026gt; \u0026lt;/LinearLayout\u0026gt; 我将原本的 ViewPager 控件备注以便比较, 其实就是替换为自定义的 NoScrollingViewPager.\n3. 修改主函数代码 到了最后一步, 回到主代码中, 结合我的示例, 在 Fragment 中加入 TabLayout 以及 ViewPager.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Fragment1 extends Fragment { private View view; private TabLayout tabLayout; private FragmentOneAdapter fragmentOneAdapter; private ViewPager noScrollingViewPager; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { view = inflater.inflate(R.layout.fragment1, container, false); initView(); return view; } private void initView() { tabLayout = (TabLayout) view.findViewById(R.id.tab_fragment1); noScrollingViewPager = (ViewPager) view.findViewById(R.id.viewpager_fragment1); fragmentOneAdapter = new FragmentOneAdapter(getChildFragmentManager()); noScrollingViewPager.setAdapter(fragmentOneAdapter); tabLayout.setupWithViewPager(noScrollingViewPager); } } 结尾 整个功能到这里就实现了, 其实是一个很简单的功能, 但是大多数例子都是缺少第三步的, 看得我这个小白一头雾水 (你倒是讲完啊) 只能说网上的实例质量参差不齐, 或者说很多坑要自己踩过才会知道.\n","date":"2020-02-08T22:00:39+08:00","permalink":"https://cgcel.github.io/posts/2020/02/08/viewpager%E7%A6%81%E7%94%A8%E6%BB%91%E5%8A%A8%E5%AE%9E%E8%B7%B5%E5%92%8C%E6%80%BB%E7%BB%93/viewpager%E7%A6%81%E7%94%A8%E6%BB%91%E5%8A%A8%E5%AE%9E%E8%B7%B5%E5%92%8C%E6%80%BB%E7%BB%93/","title":"ViewPager禁用滑动实践和总结"},{"content":"开篇 最近肺炎爆发, 虽然上班了但是因为公司要节省口罩, 所以大部分时间都在家里待岗, 正好电脑上已经不再用 ss, ssr 也准备不用了 (越来越不稳定了) 于是尝试了一下共享 V2Ray 的局域网连接, 很快就成功了, 闲得无事写篇博客记录一下.\n准备 电脑1台 安装好 V2RayN 详细步骤 设置V2RayN 因为现在懒得自己弄, 所以随便找个机场, 拿到订阅链接后在 V2RayN 中更新节点并在设置中允许局域网连接, 同时留意一下本地监听端口, 如图显示是 10808 端口.\n打开移动热点 以 win10 系统为例, 在设置中打开移动热点:\n然后在网络适配器选项中, 查看已经开启的热点并获取ip地址:\n连接热点 首先在设置中查看已开启的代理的手动设置项, 可以看到端口为 10809.\n在手机上连接热点, 并手动设置代理服务器 IP 以及端口, 从上面步骤可知分别为: 192.168.137.1 和 10809.\n到这里就大功告成了, 其他类似的共享到局域网的热点都是差不多的步骤, ssr 的设置也一样.\n","date":"2020-02-06T14:28:09+08:00","permalink":"https://cgcel.github.io/posts/2020/02/06/v2rayn%E5%B1%80%E5%9F%9F%E7%BD%91%E5%85%B1%E4%BA%AB/v2rayn%E5%B1%80%E5%9F%9F%E7%BD%91%E5%85%B1%E4%BA%AB/","title":"V2RayN局域网共享"},{"content":"前言 网上有不少关于 Arduino 串口通信的教程和示例, 但大多是单向通信的或者是照搬 Arduino 官方示例的. 正好我的自动投食机第二版考虑加物联网功能, 需要对两块板子建立串口通信, 于是整理了网上例子和实践写一篇记录.\n硬件准备 Arduino UNO R1 Arduino MEGA 2560 PC一台 库文件 SoftwareSerial.h 代码部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;SoftwareSerial.h\u0026gt; SoftwareSerial mySerial(10, 11); //Rx, Tx String data = \u0026#34;\u0026#34;; //定义字符串 void setup() { Serial.begin(9600); mySerial.begin(4800); } void loop() { //软串口接收到字符串时, 在串口监视器打印 while (mySerial.available()) { data += char(mySerial.read()); delay(20); } if (data.length() \u0026gt; 0) { Serial.print(data); data = \u0026#34;\u0026#34;; } //硬串口接收到字符串时,通过软串口将信息发送给另一块板子 while (Serial.available()) { data += char(Serial.read()); delay(20); } if (data.length() \u0026gt; 0) { mySerial.print(data); data = \u0026#34;\u0026#34;; } } 实际编译测试时, 需要留意一些硬件问题, 避免出现僵局:\nUNO 不能使用 pin2, pin3 作为软串口的输入输出口, 否则无法接受信息, 原因待查; 硬串口与软串口的波特率尽量设置成不同的, 以免打印信息混淆; 软串口波特率不宜过高, 容易造成数据乱码, 原因待查; 总结 这一个小小功能在网上还真的是挺难找的, 相似的例程也不会说明需要注意哪些问题, 就是测试成功了就发上来的那种感觉, 不过硬件开发就是要自己结合实际测试才能积累到经验, 顺便记录下来也是一个不错的学习过程.\n","date":"2019-12-03T01:19:09+08:00","permalink":"https://cgcel.github.io/posts/2019/12/03/arduino%E7%9A%84%E4%B8%BB%E4%BB%8E%E6%9C%BA%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1/arduino%E7%9A%84%E4%B8%BB%E4%BB%8E%E6%9C%BA%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1/","title":"Arduino的主从机双向通信"},{"content":"这是标题 好久没弄博客, 正好换电脑心血来潮重新配一下, 感觉新主题还挺不错的, 近期更新一下文章吧, 大概:)\n","date":"2019-12-01T23:50:09+08:00","permalink":"https://cgcel.github.io/posts/2019/12/01/%E6%8D%A2%E4%B8%AA%E4%B8%BB%E9%A2%98/%E6%8D%A2%E4%B8%AA%E4%B8%BB%E9%A2%98/","title":"换个主题"},{"content":"元旦快乐 2018 过去了，发生了不少事情，总体还算顺利(发一篇博客看看视觉效果如何)。\n壹 完成了大大小小的课设，自学了挺多东西吧，参加了实习，找到了工作。\n贰 感觉跟同学也慢慢打成一片了，可能是因为少玩 Ingress 了，今年北蓝年终聚餐也没有去，重生之后借着双倍11级然后就没怎么玩游戏了，大四还是挺忙的，比前三年要更有压力，想的东西更多。\n叁 又是一个忙碌的元旦(大家都开始做课设不过我们组已经快完成了)然后我自己也效率低下地继续着我的毕设，女朋友也有事要忙，所以就当做是普通的一天好了。\n肆 元旦的计划的话，应该就是继续宅在宿舍做毕设，查资料，玩玩手机吧，天气冷我也没有外出的欲望，最多晚上出去吃顿火锅？\n最后 祝元旦快乐，新的一年希望更精彩，偷一张 Bing 壁纸。 ","date":"2019-01-01T00:00:00Z","image":"https://cgcel.github.io/20190101.jpg","permalink":"https://cgcel.github.io/posts/2019/01/01/%E5%85%83%E6%97%A6%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/%E5%85%83%E6%97%A6%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","title":"元旦年度总结"},{"content":"前言 翻阅网上的平衡车资料，大概有两个大方向，分别为卡尔曼滤波型和直接的 PID 调节型，前期我参照了卡尔曼滤波型平衡小车的代码，效果不是很好，小车最后连直立也无法做到，也可能是我的调试方法不对，再加上卡尔曼滤波型的代码相对比较复杂，于是我全部推倒重建，尝试后者。\n模块清单:\n12V 可充电锂电池 Arduino UNO R3 L298N 电机驱动模块 MPU6050 模块 小车底座 杜邦线若干 过程 相较于卡尔曼滤波型，PID 直接调节型对初次做平衡车的新手比较友好，Youtube 上教程很多，同时也有 PID 参数整定的视频教程。\n组装 首先是组装过程，相对比较简单，觉得不放心的可以直接参照视频教程来做视频，整个系统接线图如下：\n调试 进入重要环节，首先我们将代码烧进 Arduino，然后开机试运行，如果不成功，请返回上一步检查。运行成功后，我们首先需要校正 mpu6050，参照视频，我将mpu6050校正了3遍，结果如下：\n对应修改代码参数：\n1 2 3 4 5 6 7 8 mpu.initialize(); //初始化MPU6050 devStatus = mpu.dmpInitialize(); // supply your own gyro offsets here, scaled for min sensitivity // 校正mpu6050模块, 参考https://www.youtube.com/watch?v=ce3eA8nzInE mpu.setXGyroOffset(165); mpu.setYGyroOffset(-14); mpu.setZGyroOffset(5); mpu.setZAccelOffset(528); // 1688 factory default for my test chip 值得一提的是，这一段代码是直接照搬 mpu6050 库的示例代码的，就连备注部分都是一样的。\n校正完毕后，我们需要调节小车的机械中值：\n1 2 double originalSetpoint = 183; //173, 调节小车的稳定中值, 180为默认值, 根据小车实际情况调试 到现在，小车已经能够正常做出反应，我们的调试工作准备开始，对小车进行 PID 参数整定。 参照视频，我们可以大概总结为以下流程：\n调节 Kp 值，按照从小到大的方向调试，直到小车调节反应过度（低频抖动）后再取一个比较理想的较小值 调节 Kd 值，为了减小抖动，我们需要 PD 控制，按照从小到大的方向调试，直到小车出现高频抖动后再取一个比较理想的较小值，此时小车已经能够直立一段时间 调节 Ki 值，同时 Kp、Kd 值也可以进行微调，直到最后小车能够平稳直立 贴上调试参数：\nP I D 30 0 0(反应较慢) 50 0 0 60 0 0 100 0 0(低频抖动) 150 0 0 200 0 0 150 0 0.5 150 0 1 150 0 1.5 150 0 2(高频抖动) 150 0 1.2(能直立但有抖动) 150 0 0.8(能直立但没上一组平稳) 150 0 0.9 150 0 1 120 0 1 100 0 1 65 0 1(平稳直立但移动距离比较大) 68 0 1(平稳直立) 68 50 1 68 100 1(太大) 68 40 1 70 0 1 75 0 1 72 0 1 72 0 0.9 70 0 1.05 70 50 1.05 70 60 1.05 70 70 1.05 71 70 1.05 69 70 1.05 69 90 1.05 69 90 1.1 69 90 1.2(稳定直立) 65 90 1.2(电池满电后稳定直立) 将串口输出的PWM值保存并用matlab绘制曲线图:\n总结 从一开始自信满满开始做这个课设到中途受挫（第一次答辩打回重做）再到后来的全部推倒重建，整个过程下来学习到了很多，特别是PID参数的整定，于是想要写一篇博客记录一下。\n代码已上传至GitHub\n参考链接 吃水不忘挖井人，下面贴上整个制作过程中帮助比较大的前辈们的教程：\nhttps://forum.arduino.cc/index.php?topic=519968.0\nhttps://www.geek-workshop.com/thread-704-1-1.html\nhttps://www.geek-workshop.com/forum.php?mod=viewthread\u0026tid=14868\u0026highlight=PID\nhttps://www.geek-workshop.com/forum.php?mod=viewthread\u0026tid=23\u0026highlight=PID\nhttp://www.51hei.com/bbs/dpj-47816-1.html\nhttps://www.geek-workshop.com/thread-9879-1-1.html\nhttps://maker.pro/arduino/projects/build-arduino-self-balancing-robot\nhttps://github.com/lukagabric/Franko/blob/master/Franko\nhttps://www.youtube.com/watch?v=yL43DSVdEEQ\u0026t\nhttps://www.youtube.com/watch?v=ce3eA8nzInE\nhttps://www.youtube.com/watch?v=uyHdyF0_BFo\n","date":"2018-12-21T00:00:00Z","image":"https://cgcel.github.io/%E6%95%B0%E6%8D%AE%E6%9B%B2%E7%BA%BF_2.png","permalink":"https://cgcel.github.io/posts/2018/12/21/%E5%9F%BA%E4%BA%8Earduino%E7%9A%84%E8%87%AA%E5%B9%B3%E8%A1%A1%E8%BD%A6%E7%9A%84%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/%E5%9F%BA%E4%BA%8Earduino%E7%9A%84%E8%87%AA%E5%B9%B3%E8%A1%A1%E8%BD%A6%E7%9A%84%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/","title":"基于Arduino的自平衡车的调试总结"},{"content":"开篇 前不久入了一加6, 入手第二天就升到了官方的 OxygenOS 9.0 Beta4, 吃到了官方的 pie, 体验下来, 总体感觉如下:\n优点: 指纹支付很方便, 这在氢氧两个 ROM 均有适配 类原生 UI 风格讨喜 后台清除方式分两种模式可调节, 方便不同用户群体 全面屏显示功能调节方便, 充分利用屏幕显示 Dash 闪充充电效率很高 缺点: 系统功能未完善, 比如岛 Island (炼妖壶)等相关 app 无法创建工作模式 动画粗糙, 比如切换最近任务栏时可以明显看见缩略图由原生的棱角突变为一加的圆角卡片 后台限制管理太分散: 一加将自家的后台省电与原生的 AI 省电混合使用, 用户难以分清楚两者相关作用 室内定位体验差, 一加的定位一直以来都受到诟病 (比如 ingress 室内一直在雪花) 总体来说一加的产品在国内算是非常不错的安卓旗舰机了, 今天无聊打开 xda 逛了一下一加6论坛, 发现 Pixel Experience 适配了一加6, 于是在一番准备后, 我开始了刷机.\n前期准备 这是我第三次刷 AB 分区的手机, 上一次操作是用米3和Pixel 2 XL的时候, 因此要做足准备, 不然刷成砖岂不是\u0026hellip;😂\n查询相关评测\n这一步其实是必不可少的, 任何 ROM 都会有或多或少的 bug, 要确认该 ROM 在本机上能正常使用我们才能放心去刷, 另外我习惯找比较出名的第三方 ROM, 一是有口碑有质量保证, 二是刷的人多可以借鉴他们的方法和经验, 而 Pixel Experience 是近来大家讨论比较多的 ROM. 我分别在 xda 和 youtube 上查阅, 观看了相关信息, 总结下来刷机顺序如下:\nInstall blue_spark twrp.\nClear system, cache, dalvik cache\nFlash rom and then twrp. Use the latest blu spark recovery.\nLet the rom boot first. First boot might take 10-15 mins cause.\nBoot into recovery and then flash magisk if you want to root, then boot into system.\n环境及刷机包准备\n解锁bootloader教程\nadb (不懂的请自行解决)\nROM\nTWRP(img\u0026amp;zip)\nMagisk (自选)\n开刷 从开机状态开始操作\n1 2 $ adb reboot bootloader $ fastboot boot name_of_twrp.img 如顺利, 将进入twrp. 刷入\nwipe → clear system, cache, dalvik cache\ninstall → name_of_rom.zip\ninstall → name_of_twrp.zip\ninstall → magisk.zip →reboot system\n初始化\n经过以上流程, 此ROM就算刷完了, ok可以开始体验啦:) 使用感受 系统保留了一些一加的功能:\n一些截图:\n闪充依然见效:\nPS: ingress室内秒定位, 嗯真香\u0026hellip;\n以上.\n","date":"2018-10-28T00:00:00Z","image":"https://cgcel.github.io/2018-10-28-02.jpg","permalink":"https://cgcel.github.io/posts/2018/10/28/%E4%B8%80%E5%8A%A06-pixel-experience-android-pie-%E5%88%B7%E6%9C%BA%E4%BD%93%E9%AA%8C/%E4%B8%80%E5%8A%A06-pixel-experience-android-pie-%E5%88%B7%E6%9C%BA%E4%BD%93%E9%AA%8C/","title":"一加6 Pixel Experience Android Pie 刷机体验"},{"content":"开篇 回顾我的刷机历程, 每次都是有了想法之后就行动起来了, 经历的是一次又一次的真香警告. 而本次 root 的想法的起因是黑域越来越难用, 让我想用回绿守, 本想着等 9.1 出来之后再 root, 但是每次我都会等不及\u0026hellip; 然后果不其然的踩坑了.\n刷机环境以及刷机包准备 USB驱动 adb环境 TWRP Magisk 其中, twrp 较新版本刷入之后有 bug, 上 youtube 看过教程后, 决定采用 twrp3.2.1.2, 下载时需要下载.img以及.zip文件.\n具体步骤 进入命令行\n进入 fastboot 界面\n1 $ adb reboot bootloader 解 bootloader 锁\n1 $ fastboot flashing unlock 使用音量键和电源键进行确认, 注意解锁后手机所有数据将会被清除, 要做好备份.\n刷入第三方 recovery\n1 $ fastboot boot path/twrp.img 刷入成功后, 重启进入 recovery, 此时还需要进入 install, 选择 twrp.zip 包再进行刷入. 缺少这一步的话, 下一次重启还会回到官方recovery.\n刷入 magisk 在 twrp 的 install 页面选择事先存入手机的 magisk.zip 进行刷入, 刷入后重启即可.\n结尾 整个过程下来就刷 twrp 出了些问题, 最新版本不能用是什么鬼\u0026hellip;? (勘误: 事实上只是 twrp 的加密, 输入锁屏 PIN 码即可) 好在最后还是解决了问题, 顺便写篇博客记录一下这个坑.\n","date":"2018-09-09T00:00:00Z","permalink":"https://cgcel.github.io/posts/2018/09/09/pixel-2xl-root%E6%96%B9%E6%A1%88%E8%AE%B0%E5%BD%95/pixel-2xl-root%E6%96%B9%E6%A1%88%E8%AE%B0%E5%BD%95/","title":"Pixel 2XL root方案记录"},{"content":"开篇 好久没有更新博客, 正好熟悉了一下 ss 通过局域网共享到手机, 于是写一篇博客记录下来.\n详细步骤 打开热点 首先我们打开电脑的热点, 如果没有的话就使用 wifi 共享工具打开热点, 这里使用的是 WiFi 共享精灵(顺便吐槽一下, 我一直没有找到没广告的良心工具, 换来换去还是这个最顺手, 把各种弹窗关掉将就一下吧)\n查看网络连接信息 打开网络连接, 我们可以通过名称来找到刚开启的热点, 如图为本地连接3.\n获取本机IP地址 这是非常重要的一步, 打开 cmd 或其他工具, 输入ipconfig, 第一个本地连接的 ipv4 地址就是了.\nShadowsocks设置 打开 ss 客户端, 右键其图标, 勾选允许其他设备连入.\n手机WiFi手动配置 进入 WiFi 设置, 连接时选择高级选项, 据观察, 如果已经连接过此热点, Android 9.0 可以直接设置, 而 8.1 需要 forget 后重新设置. 如图, proxy 选手动, 然后将本机 IP 地填写进去, 端口亲测 1080 可行, 网上说的 8123 不行 (更正: 需要以 ss 的 proxy 代理端口为准). 其他选项默认即可, 保存后即可科学上网啦.\n","date":"2018-09-05T00:00:00Z","permalink":"https://cgcel.github.io/posts/2018/09/05/shadowsocks%E5%B1%80%E5%9F%9F%E7%BD%91%E5%85%B1%E4%BA%AB/shadowsocks%E5%B1%80%E5%9F%9F%E7%BD%91%E5%85%B1%E4%BA%AB/","title":"Shadowsocks局域网共享"},{"content":"前期准备 在我接触单片机的时候就已经知道树莓派的厉害, 这是一台低功率计算机, 同时还可以当作一台高性能的单片机使用. 3月的时候入了一台树莓派3b, 一直积灰到现在, 终于在考试, 课设全部结束之后有空玩一玩了.\n系统安装 系统下载 系统安装还不算太麻烦, 直接去 官网 下载镜像即可, 第一次装系统的话还是选官方提供的东西吧, 我们选择下载 Raspbian 系统, 这是专门为树莓派提供的 Debian 系统, 有两个版本可供选择:\nRaspbian Stretch with desktop Raspbian Stretch Lite 前者是带图形界面的版本, 后者是只有命令行页面的轻量级版本, 为了轻便, 我选择了Lite版.\n刷入 Raspbian 下载完毕后, 使用 SDFormatter 将 SD 卡格式化, 然后使用 Win32DiskImager 将系统写进 SD 卡, 类似工具有很多, 自己选用一个即可 (官网更新了官方工具 Raspberry Pi Imager, 使用起来更为方便), SD 卡容量方面, 很多教程都是选择了最低限度的 2GB 的 SD 卡, 然而这都已经是古董级别的卡了, 一般在街上只能买到最低 16GB 的. 使用 Win32DiskImager 写入系统成功后, 会弹窗询问是否格式化 SD 卡, 这时候点取消就行, 不然又要重新写一遍.\n注意事项 据说新版本的 Raspbian 默认关闭了 ssh, 需要先在 SD 卡的 boot 分区新建一个 ssh 文件夹. 将 SD 插入树莓派后供电, 看到绿灯闪烁就是系统运行成功了.\nssh连接 树莓派有多种连接电脑的方式, 比如TTL转USB连接和网线连接, 用的比较多的是网线连接, 网上有很多教程, 放一个 我参考的.\n用网线连接初次尝试可能会比较麻烦, 但试多几次就会熟练了, 一定要按照步骤一步一步来, 不然树莓派就分配不到 IP 地址了.\n更新软件源 使用 ssh 连接上 Pi 的时候, 输入用户名密码就可以登录系统并进行操作了, 默认用户名: Pi, 默认密码: raspberry, 进入命令行页面后, 我们可以通过更换软件源来解决更新速度慢的问题, 我们采用清华源, 按照以下步骤操作:\n使用管理员权限，编辑 /etc/apt/sources.list 文件。参考命令行为：\n$ sudo nano /etc/apt/sources.list\n用 # 注释掉原文件内容，用以下内容取代：\n1 2 deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi 使用管理员权限，编辑 /etc/apt/sources.list.d/raspi.list 文件。参考命令行为：\n$ sudo nano /etc/apt/sources.list.d/raspi.list\n用 # 注释掉原文件内容，用以下内容取代：\n1 2 deb http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui deb-src http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui 保存并退出后, 执行以下命令即可:\n1 2 $ sudo apt-get update $ sudo apt-get upgrade ","date":"2018-07-17T00:00:00Z","permalink":"https://cgcel.github.io/posts/2018/07/17/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8Assh%E8%BF%9E%E6%8E%A5/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8Assh%E8%BF%9E%E6%8E%A5/","title":"树莓派系统安装以及ssh连接"},{"content":"开篇 最近一直对手机的 3.1GB/3.8GB 的内存占用感到不爽, 想要压缩到 2.8GB 左右, 于是开始填坑 gcm-for-mojo , 这是一个获取网页端微信信息并通过 gcm 推送到客户端的 app, 同时他也支持 mipush, hwpush 等等国内平台的推送, 由于手机是 Pixel 2 XL, 原生系统自然用 gcm 就 ok 了, 微信客户端现在内存占用是越来越大了, 把后台关了也有接近300M, 而使用一些工具替代微信的后台接收信息工作, 自然就达到了省电省内存的效果了.\n服务器配置 本人常用微信, 于是就只做了微信的推送, QQ 配置方法类似, 基本上举一反三, 很容易学会. 首先我们在服务器上安装 perl, Ubuntu 16.04 操作如下:\n1 $ sudo apt-get install perl cpanminus git make screen libssl-dev libnet-ssleay-perl libio-socket-ssl-perl 完成后\n1 $ cpanm Mojo::Weixin 我们直接到 GitHub 上看配置步骤, 描述得很详细, 最多几分钟就可以搞定了.\n接下来我们新建一个 wx.pl 文件, 命名随意, 内容如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 use Mojo::Weixin; my $client = Mojo::Weixin-\u0026gt;new(log_encoding=\u0026gt;\u0026#34;utf-8\u0026#34;); $client-\u0026gt;load(\u0026#34;ShowMsg\u0026#34;); $client-\u0026gt;load(\u0026#34;GCM\u0026#34;,data=\u0026gt;{ api_url =\u0026gt; \u0026#39;https://gcm-http.googleapis.com/gcm/send\u0026#39;, api_key=\u0026gt;\u0026#39;AIzaSyB18io0hduB_3uHxKD3XaebPCecug27ht8\u0026#39;, registration_ids=\u0026gt;[\u0026#34;令牌, 客户端获取\u0026#34;], allow_group=\u0026gt;[\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;], # 群聊信息推送白名单 ban_group=\u0026gt;[], allow_discuss=\u0026gt;[], ban_discuss=\u0026gt;[], is_ban_official =\u0026gt;1, # 不接收公众号信息 }); $client-\u0026gt;load(\u0026#34;Openwx\u0026#34;,data=\u0026gt;{ listen =\u0026gt; [ {host=\u0026gt;\u0026#34;服务器ip地址\u0026#34;,port=\u0026gt;140}, ] , #其中, 端口号自定义, 如140, 需要在客户端设置中填入ip:port格式的地址才能开通快速回复功能, 如下图 }); $client-\u0026gt;run(); 将 wx.pl 上传至服务器, 使用 nohup perl wx.pl \u0026amp; 使其在后台运行. 这是个效果不太好的方法, 断开 ssh 连接时很容易把进程也关掉, 翻阅教程时我发现可以用另一个方法来实现后台运行:\nscreen -S docker perl wx.pl 此时断开 ssh 连接也不受任何干扰, 放置后台成功. 如果想回到 screen, 可以使用以下指令, 结束操作后挂起即可:\nscreen -ls screen -r pid 附上一篇 screen 使用教程\n优势与不足 优势: gcm-for-mojo 配置起来比 EFB 要简单得多,毕竟依赖没有后者多 fcm 推送很及时 自定义设置比较丰富 不足: 比起 EFB, gcm-for-mojo不能显示图片和表情包, 甚至 emoji 也不会显示 使用 nohup 指令让其在后台运行时, 与服务器断开连接后有一次会自动关闭后台进程 不够稳定, 一方面 WebWeixin 本身就是个神奇的东西, 诸如 ItChat, EFB, gcm-for-mojo 这些借助网页版微信获取信息的工具会导致账号被封(一段时间内将无法使用网页登录) 总结 之前用过 EFB1.0, 没多久就弃了, 原因是连接很容易断开, 一旦断开连接就要再重新扫码登录, 而微信无法在本机上扫码登录, 于是就比如借助另一个设备显示二维码, 可以想象有多麻烦, 当然 gcm-for-mojo 也是如此, 正好借此机会对比一下两者的稳定性, 希望这次能用久一点吧🤷‍♀️\n","date":"2018-07-06T00:00:00Z","permalink":"https://cgcel.github.io/posts/2018/07/06/gcm-for-mojo%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93/gcm-for-mojo%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93/","title":"Gcm-for-Mojo搭建总结"},{"content":"开篇 终于结束了好几门考试, 有时间更新一下博客了, 就记录一下几天前给一加1卡刷 lineage15.1 吧.\n突如其来的更新 之前有一段时间一直在等官方更新一加1的 lineage15.1, 有空就刷新一下官网, 但始终没有发布, 于是就先把 lineage14.1 刷了. 直到几天前检测更新, 发现有无法 ota 更新的更新, 仔细一看原来是 lineage15.1, 而且已经更新了两版, 于是我迫不及待下载了安装包.\n踩坑 备份后进入 twrp 四清手机, 然后开始卡刷, 然而报错了:\nThis package is for \u0026quot;OnePlus\u0026quot; devices: this is a \u0026quot;A0001\u0026quot;\n经查询, 发现是 twrp 版本太低了, 换了最新的 twrp 一试, 果然成功了, 随后就是刷 gapps, magisk, 常规操作就不说了.\n开机 开机初始化后进入系统, 还是和以往版本一样流畅, 附上一些截图, 短暂使用后只发现了一个奇怪的bug: 刺激战场开伞后就闪退, 进游戏无法返回正在进行的游戏\u0026hellip;\n下面附上一些截图:\n升级 今天系统迎来了一次更新, 只有300M左右, 于是就直接用流量下载了, 重启后发现保留了 root 效果, 之前 14.1 时候用 superSU, 每次更新之后就要重新刷一遍才有 root 效果. 顺带一提, 更新之后舍友拿去吃鸡不闪退了 (印度人很喜欢吃鸡, 很多ROM更新之后如果玩不了都会有人在评论反馈😂)\n结尾 终于如愿以偿让备机吃上了 oreo, 体验也很好, 不过这应该是一加1能刷到的最新的版本了吧, 感觉 9.0 希望不大, 不过也很难得了, 毕竟这么老的机型了, 到现在还是很流畅, 刺激战场什么的也压力不大. 改天试一试 rr 好了, 其实 rr 给一加1适配 andoid 8.1 比 lineage 要早, 之前下下来一直刷不上就放弃了. 最后贴一下链接:\nlineageos下载 adb下载 gapps下载 twrp下载 ","date":"2018-07-04T00:00:00Z","image":"https://cgcel.github.io/2018-07-04-01.jpg","permalink":"https://cgcel.github.io/posts/2018/07/04/%E4%B8%80%E5%8A%A01%E5%8D%A1%E5%88%B7lineage15.1/%E4%B8%80%E5%8A%A01%E5%8D%A1%E5%88%B7lineage15.1/","title":"一加1卡刷lineage15.1"},{"content":"开篇 5.20前后几天, 六维空间开放注册, 于是久仰大名的我也跑去注册了一个账号, 因为六维空间每日登录都会送5浮云, 因此就有了写一个模拟登录拿每日奖励的脚本的想法, 将其放在校园网登录脚本里面一起跑就美滋滋了.\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 # -*- coding: utf-8 -*- # author: Chan import requests from bs4 import BeautifulSoup url_start = \u0026#39;http://bt.neu6.edu.cn/member.php?mod=logging\u0026amp;action=login\u0026amp;referer=http%3A%2F%2Fbt.neu6.edu.cn%2Fforum.php\u0026#39; url_login = \u0026#39;http://bt.neu6.edu.cn/\u0026#39; url_main = \u0026#39;http://bt.neu6.edu.cn/forum.php\u0026#39; url_test = \u0026#39;http://bt.neu6.edu.cn/home.php?mod=spacecp\u0026#39; class neu6(): def __init__(self, username, password): headers = { \u0026#34;Accept\u0026#34;: \u0026#34;text/html, application/xhtml+xml, application/xml\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN, zh\u0026#34;, \u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age = 0\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;, \u0026#34;Host\u0026#34;: \u0026#34;bt.neu6.edu.cn\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0Win64x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36\u0026#34; } self.session = requests.Session() self.session.headers.update(headers) self.username = username self.password = password r = self.session.get(url_start) soup = BeautifulSoup(r.content, \u0026#39;html.parser\u0026#39;) self.formhash = soup.find(\u0026#34;input\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;formhash\u0026#34;})[\u0026#34;value\u0026#34;] self.action = soup.find(\u0026#34;form\u0026#34;)[\u0026#34;action\u0026#34;] def login(self): try: formdata = { \u0026#34;formhash\u0026#34;: self.formhash, \u0026#34;referer\u0026#34;: url_main, \u0026#34;username\u0026#34;: self.username, \u0026#34;password\u0026#34;: self.password, \u0026#34;questionid\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;answer\u0026#34;: \u0026#34;\u0026#34; } self.session.post(url_login+self.action+\u0026#39;\u0026amp;inajax=1\u0026#39;, data=formdata) r1 = self.session.get(url_main) except: print(\u0026#34;登录失败\u0026#34;) def info(self): try: r2 = self.session.get(url_main) soup = BeautifulSoup(r2.content, \u0026#39;html.parser\u0026#39;) name = soup.find_all(\u0026#34;strong\u0026#34;, {\u0026#34;class\u0026#34;: \u0026#34;vwmy\u0026#34;})[0].get_text() points = soup.find_all(\u0026#34;a\u0026#34;, {\u0026#34;class\u0026#34;: \u0026#34;showmenu\u0026#34;})[ 0].get_text().strip() level = soup.find_all(\u0026#34;a\u0026#34;, {\u0026#34;class\u0026#34;: \u0026#34;xi2\u0026#34;})[ 0].get_text().strip() print(\u0026#34;用户名:\u0026#34;, name) print(points) print(\u0026#34;用户组:\u0026#34;, level) except: print(\u0026#34;获取信息失败\u0026#34;) def main(): neu = neu6(\u0026#39;username\u0026#39;, \u0026#39;passowrd\u0026#39;) neu.login() neu.info() if __name__ == \u0026#39;__main__\u0026#39;: main() 通过看网页源码我们能发现, post 的数据不仅仅是用户名和密码, 他的完整数据如下:\n1 2 3 4 5 6 7 8 formdata = { \u0026#34;formhash\u0026#34;: self.formhash, \u0026#34;referer\u0026#34;: url_main, \u0026#34;username\u0026#34;: self.username, \u0026#34;password\u0026#34;: self.password, \u0026#34;questionid\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;answer\u0026#34;: \u0026#34;\u0026#34; } 幸运的是,这些数据都可以在登录前的页面获取到, 具体做法见代码. 将他放进一键登录程序中, 也可以写到 .bat 文件什么的来轻松登录, 甚至还可以帮舍友, 朋友一起登录.\n如图, 登录成功:P\n结尾 好吧, 其实我只是想玩玩我新建好的博客, 于是就随便拿点小东西发上来了, 有需要的话就拿走吧:P 如果有更好的方法也请告诉我一下, thx.\n","date":"2018-06-23T00:00:00Z","image":"https://cgcel.github.io/2018-6-23-1.png","permalink":"https://cgcel.github.io/posts/2018/06/23/%E5%85%AD%E7%BB%B4%E7%A9%BA%E9%97%B4%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/%E5%85%AD%E7%BB%B4%E7%A9%BA%E9%97%B4%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/","title":"六维空间自动登录脚本"},{"content":"起因 Jekyll 的加载速度实在是有点慢, 在刚上线不久后, 我又得知了一个页面加载更快的方法: 使用 Hugo 搭建博客.\n搭建环境 到 下载页面 下载 Windows 版本的 hugo, 遇到了坑, 最新版本无法在本地预览页面(v0.42.1)于是我下载了和教程一样的老版本, 以确保能够顺利调试.\n配置 因为才折腾过 jekyll, 加上 hugo 比前者的配置要简单, 所以我很快就改好了 config 文件, 这里要注意的一点是, 要先下载好主题再在根目录使用 hugo server -D 指令, 否则页面会一片空白.\n基础知识学习(Go templates) 列一下适合初学者学习的链接:\nYouTube 官方文档 函数以及变量 模板选择 不得不说模板的选择真是一道难题, 就算是在 hugo 官方提供的模板页面中下载的模板也还是要会有一些 bug\u0026hellip;因为想要 Tags 功能,自己照葫芦画瓢写也有点丑, 所以在上一个模板刚配置完的时候我又换了一个模板, 这个模板刚好有 bug ( baseurl 和 css 等链接之间少了\u0026rsquo;/\u0026rsquo;) 本菜鸟找了快一个小时才找出来\u0026hellip;\n编写博客 只需要在根目录命令行输入 hugo new ***/***.md 就可以自动创建新文章, 并且hugo会帮忙自动生成标题等信息.\n1 2 3 4 5 6 +++ title= \u0026#34;使用hugo创建博客\u0026#34; date= 2018-06-22T19:34:37+08:00 categories=[\u0026#39;tech\u0026#39;] tags= [\u0026#39;hugo\u0026#39;,\u0026#39;go\u0026#39;,\u0026#39;github.io\u0026#39;] +++ 填好以上格式, 就可以开始在下面写博客了, 和 jekyll 非常相似.\n新版本的 hugo 自动生成的 .md 文件格式有点变化, 如下所示:\n1 2 3 title: \u0026#34;换个主题\u0026#34; date: 2019-12-01T23:50:09+08:00 categories: [\u0026#34;daily\u0026#34;] 部署到github.page 和 jekyll 相比, hugo 的部署/文章推送略微麻烦一点, 前者只需要修改并预览检查完毕后直接全部 push 即可, 而 hugo 按照官方文档的方法是先在根目录运行一道指令 hugo --baseUrl=\u0026quot;https://username.github.io\u0026quot; , 在根目录生成 public 文件夹, 然后将 public 文件夹中的所有内容 push 至仓库中. 我查阅了一些其他的自动化方法, 如Travis. 最后嫌配置麻烦, 直接在根目录创建了一个 .bat 文件,将几个指令写进去依次运行, 也算是实现了一键推送的功能, 也算是提供了另一种思路吧.\n1 2 3 4 5 6 7 hugo --theme=pure --baseUrl=\u0026#34;https://koonchung.github.io\u0026#34; cd public git add . git commit -m \u0026#34;auto-uploaded files\u0026#34; git push -u origin master pause 暂告一段落 emm\u0026hellip;写到这里已经半夜一点半了, 那就先告一段落吧, 最后总结一下, 不得不说 hugo 加载的速度比 jekyll 快了不少, 模板配置完成后体验很不错.\n","date":"2018-06-22T00:00:00Z","permalink":"https://cgcel.github.io/posts/2018/06/22/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/","title":"使用hugo创建博客"},{"content":"开篇 最近学习 Django 开发网页, 后来由于 Django 开发比较繁琐以及可迁移性较差, 于是转学 flask, 从而有了这一篇文章, 顺便测试一下我的博客发文功能:P\n项目依赖 虽然 flask 较 Django 更轻量, 版本间语法差别不大, 但还是会有一些小坑. 比如在使用 flask-sqlalchemy 时报错, 原因是版本过新或过旧, 另外 flask 的扩展包需要另外安装, 这里注意一下就行. 下面列出个人博客项目的安装依赖 ( python3.5 \u0026amp; python3.6 测试通过):\n1 2 3 4 Flask_SQLAlchemy==2.1 Flask==1.0.2 Markdown==2.6.11 Flask_Bootstrap==3.3.7.1 数据库 数据库的使用是网页编写的一个非常重要的部分, 基本上读取, 存入, 登录, 注销等等操作都和数据库相关, 本项目使用 sqlite3, 操作起来较为简单. 简单总结一下 flask-sqlalchemy 的使用技巧:\n路径: 1 2 3 4 MySQL: mysql+pymysql://username:password@hostname/database Postgres: postgresql://username:password@hostname/database SQLite(Unix): sqlite:////absolute/path/to/database SQLite(Windows): sqlite:///c:/absolute/path/to/database 初始化: 1 2 3 4 app = Flask(__name__)\u0026lt;br\u0026gt; app.config[\u0026#39;SQLALCHEMY_DATABASE_URI\u0026#39;] = \u0026#39;sqlite:///E:/code/Python/flask/Elvin_Blog/schema.sql\u0026#39; app.config[\u0026#39;SQLALCHEMY_TRACK_MODIFICATIONS\u0026#39;] = False db = SQLAlchemy(app) 操作语句: 1 2 3 4 5 6 7 8 9 User.query.all() # 搜索所有信息 User.query.get(id) # 搜索对应主键信息 User.query.filter_by(username=\u0026#39;\u0026#39;).all() User.query.filter_by(username=\u0026#39;\u0026#39;).first() db.session.add(User(username,password)) db.session.commit() # 修改信息 User.query.filter_by(id=id).first().username=\u0026#39;newusername\u0026#39; db.session.commit() 自定义过滤器 我希望能将 markdown 格式的内容转化并直接显示, 这就需要用到 flask 的过滤器功能, 阅读了相关文章, 只需要自定义一个过滤器, 代码如下:\n1 2 3 4 5 from flask import Markup import markdown @app.template_filter(\u0026#39;toMarkdown\u0026#39;) def toMarkdown(content): return Markup(markdown.markdown(content)) 通过 jinja2 调用时, 只需要 { { content|toMartdown } } 即可.\n用户登录与登出 通过 MD5 加密密码并保存在数据库, 使用 flask 的 session, 登录成功后, 代码添加 session['username'] = username , 同理, 在进入一些诸如管理页面的页面时, 只需要添加 if 'username' in session: 加以判断即可.\n","date":"2018-06-21T00:00:00Z","permalink":"https://cgcel.github.io/posts/2018/06/21/flask%E8%B8%A9%E5%9D%91%E5%92%8C%E6%8E%92%E5%9D%91%E8%AE%B0%E5%BD%95/flask%E8%B8%A9%E5%9D%91%E5%92%8C%E6%8E%92%E5%9D%91%E8%AE%B0%E5%BD%95/","title":"flask踩坑和排坑记录"},{"content":"开篇 看到过不少用 github page 搭建的个人博客, 感觉非常方便. 加上前不久刚学了 flask, 对搭建个人博客挺感兴趣, 于是在网上找了一些教程, 开始创建博客, 这里做一下简单的总结.\n创建仓库 在 github 新建项目, 命名格式为 \u0026lt;username\u0026gt;.github.io, 最好先选 private, 因为可能会有很多误操作. 然后在本机 (Windows) 安装环境: gem, jekyll 等等, 安装这些是便于在本地修改网页并且预览,这样就不用每次都 push 到 github 来试了. 不过 Windows 安装起来挺麻烦的, 一定要按照教程一步一步来设置, 跟教程有一些出入的地方要自己判断.\n选择主题 jekyll 的主题有很多,我们可以在 github 和网页上挑选, 本来我想要选一个 md 格式的主题,奈何一时间找不到,于是从 github 上选择了一个纯白的极简主题.\n自定义页面内容 选好主题之后, 通过 git 把代码 clone 到本地, 首先必须要编辑的是 _config.yml,按照个人的信息和需求进行增减改动, 如果不知道该怎么改, 建议多找几个主题对比一下文件内容, 也可以到 YouTube 找一下相关视频教程. 设置完后, 就可以去自定义个人信息和网页显示内容了.\n预览和推送测试 修改完文件后,在项目根目录打开 cmd, 输入 jekyll s, 如果没有报错就表示在本地运行成功了, 此时可以打开浏览器, 进入 127.0.0.1:4000 就可以预览页面. 按照格式命名文章, 如: 2018-6-21-title.md, 在文章开头加上以下内容就可以被识别并更新在主页上了, 非常方便:\n1 2 3 4 5 6 --- layout: post title: \u0026#34;your title\u0026#34; date: 2018-06-21 categories: --- ","date":"2018-06-21T00:00:00Z","permalink":"https://cgcel.github.io/posts/2018/06/21/github.io%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/github.io%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"github.io博客搭建"}]