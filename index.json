[{"content":"起因 由于前一段时间换了iPhone, 导致原本把音乐文件存在本地听歌的白嫖习惯中断了, 使用iTunes实在是不方便 (需要固定一台pc管理本地音乐文件), 加之不想用iCloud服务, 因此我在tg上用缓存听了一个多月的歌\u0026hellip;\n树莓派放在东莞家里, 一直跑着qbittorrent-nox以及frps服务, 这两个都是日常使用很频繁的服务, 树莓派跑起来也是绰绰有余. 最近由于东莞疫情, 已经很久没有回去, 于是正好在休息日折腾一下很久没管的树莓派, 给树莓派装上nextcloud, 用来当作自己的网盘, 把音乐文件存入, 方便手机同步.\n安装过程 安装apache2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # 1.安装命令 sudo apt-get install apache2 # 2.启动apache2 systemctl start apache2 # 3.设置apache2开机自启 systemctl enable apache2 # 附上其他命令 # 查看运行状态 systemctl status apache2 # 重启 systemctl restart apache2 # 停止 systemctl stop apache2   安装php 1 2 3 4 5  # 1.安装php sudo apt-get install php libapache2-mod-php -y # 2.安装其他组件 sudo apt-get -y install php-fpm php-cli php-json php-curl php-imap php-gd php-mysql php-xml php-zip php-intl php-imagick php-mbstring -y   安装mariadb 1 2 3 4 5 6 7 8 9 10 11 12  # 1.安装 sudo apt-get install mariadb-server -y # 2.开启远程登陆权限 # 2.1 切换目录 d /etc/mysql/mariadb.conf.d # 2.2 找到修改权限的文件 grep -rn \u0026#34;skip-networking\u0026#34; * # 显示如下：在50-server.cnf文件的第26行 50-server.cnf:26:# Instead of skip-networking the default is now to listen only on # 2.3 编辑文件，注释掉 bind-address = 127.0.0.1 sudo nano 50-server.cnf   创建数据库用户以及添加数据库\n1 2 3 4 5 6 7 8 9 10 11 12  # 直接回车 不需要输入密码 mysql -uroot -p # account可替换成自定义的用户名，password可替换成自定义的密码 create database nextcloud; CREATE USER \u0026#39;account\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; GRANT ALL PRIVILEGES ON *.* TO \u0026#39;oc_admin\u0026#39;@\u0026#39;%\u0026#39; WITH GRANT OPTION; flush privileges; CREATE USER \u0026#39;account\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; GRANT ALL PRIVILEGES ON *.* TO \u0026#39;account\u0026#39;@\u0026#39;localhost\u0026#39; WITH GRANT OPTION; flush privileges;   安装nextcloud 从官网下载.tar.bz2的压缩包\n下载完成后, 需要上传到树莓派的 /var/www/html/ 目录下. 然后执行以下命令.\n1 2 3 4 5 6 7 8 9 10  # 1.解压文件 tar jxf nextcloud-21.0.0.tar.bz2 # 2.添加data目录和授权 chown -R root:root nextcloud # 3.进入nextcloud文件夹 cd nextcloud # 4.创建数据文件夹 mkdir data # 5.添加权限和授权 chown -R www-data:www-data data config apps   (可选) 如果是在非root权限下操作, 可以先上传至树莓派, 剪切到 /var/www/html/ 目录后再进行解压.\n初始化nextcloud 准备 初始化前, 由于我的树莓派开启了ufw, 所以先开启防火墙端口白名单:\n1  sudo ufw allow 80/tcp   由于我的树莓派挂载一个1TB的移动硬盘, 为了充分利用以及避免后续操作, 先设置好硬盘开机自动挂载. 首先在命令行中输入:\n1  df -a   可以看到, 图中我已经对1TB的移动硬盘 /dev/sda1 进行了挂载, 挂载目录为事先创建好的目录 /mnt/usb-1.\n接着, 命令行输入以下指令, 查看移动硬盘格式:\n1  sudo fdisk -l   从上图可以看出, 我的移动硬盘为NTFS格式, 接下来寻找或者创建一个自己想要挂载的目录, 然后编辑 /etc/fstab, 在文件中添加以下内容:\n1  /dev/sda1 /mnt/usb-1 ntfs defaults 0 0   保存退出后, 命令行输入 sudo mount -a, 挂载后, 输入 df -a 查看是否成功挂载.\n(可选) 通过域名访问 由于之前找电信要了公网ip, 树莓派动态绑定了阿里云域名, 这里通过添加路由器虚拟服务器, 如下图所示, 外部端口选择自己想要映射的端口, 内部服务器IP填写树莓派在家中局域网的IP, 启用后便可在公网通过 域名:外部端口/nextcloud 的方式访问nextcloud页面.\n初始化 在完成了上述准备后, 便可以进行nextcloud的初始化. 在局域网中访问 树莓派IP:80/nextcloud 或在公网中访问 域名:外部端口/nextcloud 即可.\n在初始化页面中, 根据实际情况填写相关输入框:\nNTFS挂载的一些问题 由于挂载格式是NTFS, 导致初始化完成后, 页面显示 您的数据目录可被其他用户读取, 请更改权限为0770以避免其他用户查看目录, 经查询, 可以修改nextcloud目录下的 config/config.php 来解决, 按照我的安装目录, 定位至 /var/www/html/nextcloud/config , 编辑 config.php, 在文件中添加以下内容:\n1  \u0026#39;check_data_directory_permissions\u0026#39; =\u0026gt; false,   保存关闭后, 刷新nextcloud页面, 问题解决.\n使用 在PC端, 将本地音乐文件上传至nextcloud.\n并将存放音乐的nextcloud文件夹添加至本地.\n在手机端下载evermusic, 通过webdev连接nextcloud, 注意url一栏填写: xxx:port/nextcloud/remote.php/webdev, 其他的按照个人设置填写.\n连接上nextcloud后, 即可随心所欲听歌, 也可以选择将歌曲下载至本机.\n结尾 经过一番折腾, 终于比较优雅地实现了把音乐文件存到iPhone的功能, 坚持恢复这种方式来听歌的起因也很简单, 那就是网易云时不时就下架我歌单的歌, 因此戒掉网易云, QQ也是理所当然的.\n参考内容  https://cynosure.online/2021/08/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BANextcloud%E7%A7%81%E6%9C%89%E4%BA%91 https://its401.com/article/jdyanghang/102828553  ","permalink":"https://cgcel.github.io/posts/2022/03/21/","summary":"起因 由于前一段时间换了iPhone, 导致原本把音乐文件存在本地听歌的白嫖习惯中断了, 使用iTunes实在是不方便 (需要固定一台pc管理本地音乐文件), 加之不想用iCloud服务, 因此我在tg上用缓存听了一个多月的歌\u0026hellip;\n树莓派放在东莞家里, 一直跑着qbittorrent-nox以及frps服务, 这两个都是日常使用很频繁的服务, 树莓派跑起来也是绰绰有余. 最近由于东莞疫情, 已经很久没有回去, 于是正好在休息日折腾一下很久没管的树莓派, 给树莓派装上nextcloud, 用来当作自己的网盘, 把音乐文件存入, 方便手机同步.\n安装过程 安装apache2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # 1.安装命令 sudo apt-get install apache2 # 2.启动apache2 systemctl start apache2 # 3.设置apache2开机自启 systemctl enable apache2 # 附上其他命令 # 查看运行状态 systemctl status apache2 # 重启 systemctl restart apache2 # 停止 systemctl stop apache2   安装php 1 2 3 4 5  # 1.","title":"树莓派4安装nextcloud记录 (非docker安装法)"},{"content":"前言 在试用了一天多 ColorOS 之后, 鉴于其后台管理过于严格, 我又趁午休时间刷回了 OOS, 之前已经有了用 TWRP 保留 root 的全量包更新经验和文章, 本篇只想快速记录一下.\n准备工作  9008 线刷包 (OOS) payload_dumper Magisk-v23.0.apk  步骤 步骤一: 刷回 OOS  进入 开发者选项, 勾选 允许 OEM 解锁, 开启 USB 调试, 然后关机静置. 同时按住 音量+ 和 音量-, 然后用 USB 线连接电脑, 开启 9008 线刷, 刷机完毕后重启进入系统.  步骤二: 解锁 OOS 并 ROOT   进入 开发者选项, 勾选 允许 OEM 解锁, 开启 USB 调试, 然后输入以下指令:\n1 2 3 4  adb devices adb reboot bootloader fastboot devices fastboot oem unlock   使用 \u0026ldquo;音量键\u0026rdquo; 和 \u0026ldquo;电源键\u0026rdquo; 确定解锁手机, 然后完成初始化进入系统.\n  root步骤参考上一篇文章, 此处省略.\n  步骤三: 更新系统   下载要更新的全量包, 复制多一份至电脑或手机 (取决你从哪一端下载)\n  在电脑端, 使用 payload_dumper 提取 OOS.zip 的 boot.img, 并将其复制到手机存储中.\n  安装并打开 Magisk, 选择 \u0026ldquo;安装\u0026rdquo;, \u0026ldquo;选择并修补一个文件\u0026rdquo;, 选择置入手机的 \u0026ldquo;boot.img\u0026rdquo;, 最后点 \u0026ldquo;开始\u0026rdquo;, Magisk 会生成一个类似于 magisk_patched-xxx.img 的文件, 将其复制一份到电脑:\n  安装系统更新, 安装完毕后重启进入系统桌面:\n检查 root 权限, 发现此时是没有 root 的:\n  刷入 magisk_patched-xxx.img, 根据以下指令完成:\n1 2 3 4  adb devices adb reboot bootloader fastboot devices fastboot flash boot magisk_patched-xxx.img   刷入完成后, 重启进入系统, 打开 \u0026ldquo;设置\u0026rdquo; 以及 \u0026ldquo;Magisk Manager\u0026rdquo; 查看系统信息以及 root 情况:\n  结尾 至此, 成功尝试了 OOS 的全量包更新并保持 ROOT 权限, 之前是依靠 TWRP 以及 Magisk 中的模块自动化完成的, 这次全部自己操作, 还是积累到一点经验的.\n","permalink":"https://cgcel.github.io/posts/2021/05/22/","summary":"前言 在试用了一天多 ColorOS 之后, 鉴于其后台管理过于严格, 我又趁午休时间刷回了 OOS, 之前已经有了用 TWRP 保留 root 的全量包更新经验和文章, 本篇只想快速记录一下.\n准备工作  9008 线刷包 (OOS) payload_dumper Magisk-v23.0.apk  步骤 步骤一: 刷回 OOS  进入 开发者选项, 勾选 允许 OEM 解锁, 开启 USB 调试, 然后关机静置. 同时按住 音量+ 和 音量-, 然后用 USB 线连接电脑, 开启 9008 线刷, 刷机完毕后重启进入系统.  步骤二: 解锁 OOS 并 ROOT   进入 开发者选项, 勾选 允许 OEM 解锁, 开启 USB 调试, 然后输入以下指令:\n1 2 3 4  adb devices adb reboot bootloader fastboot devices fastboot oem unlock   使用 \u0026ldquo;音量键\u0026rdquo; 和 \u0026ldquo;电源键\u0026rdquo; 确定解锁手机, 然后完成初始化进入系统.","title":"一加8T全量包升级并保留ROOT"},{"content":"前言 距离一加 8T 的发布已经过去了大半年, 据说一加 8T 的 ColorOS 会在6月底释出, 大家都说大氢亡了🥴, 但是我不用氢啊🤡, 加上氧最近也用的有些腻了, 正好前一段时间关注到 8T 的 xda 论坛 挺活跃的, 已经有不少的 ROM 可以刷了:\n于是我就打算利用空闲时间刷一刷手里的 8T 解解馋, 玩累了正好回 ColorOS (如果一加不鸽的话\u0026hellip;)\n本篇将分为两大部分来记录, 分别是:\n OOS 刷 LOS 的记录 LOS 刷回 OOS 并 root 的记录  OOS 刷 LOS 准备 在准备刷机前, 我们需要 备份好数据, 并安装或下载好以下内容 (下载包以本篇博客日期为准, 如参考则需尽量下载最新包):\n adb (基本操作了, 没有adb就无法通过指令控制手机) 9008救砖包 (随时准备好救砖) lineage-18.1-20210513-nightly-kebab-signed.zip lineage-18.1-20210513-recovery-kebab.img copy-partitions-20210323_1922.zip GAPPS Magisk-v23.0.apk  具体步骤 详细刷机步骤参考 官方文档 , 下面我将按照具体指令来总结, 这样比较明了, 不用看详细的文字解释:\n  进入 开发者选项 并开启 OEM 解锁 以及 USB调试\n  检测 adb 连接情况后进入 bootloader, 然后解锁手机:\n1 2 3 4  adb devices adb reboot bootloader fastboot devices fastboot oem unlock   通过音量键和电源键, 将手机解锁, 手机将清除所有数据, 完成初始化后, 继续进入 开发者选项 并开启 OEM 解锁 以及 USB调试\n  重启至 bootloader, 刷入 recovery:\n1 2 3 4 5  adb devices adb reboot bootloader fastboot devices fastboot flash recovery lineage-18.1-20210513-recovery-kebab.img fastboot reboot recovery     在 recovery 中, 将 A分区数据复制到 B分区, 避免B分区固件太久导致黑砖, 点击 \u0026ldquo;Apply Update\u0026rdquo;, 然后点击 \u0026ldquo;Apply from ADB\u0026rdquo;:\n1  adb sideload copy-partitions-20210323_1922.zip    签名验证失败的话, 点击 \u0026ldquo;Yes\u0026rdquo; 继续刷入即可.\n 点击 \u0026ldquo;Advanced\u0026rdquo;, 然后点击 \u0026ldquo;Reboot to recovery\u0026rdquo;\n  在 recovery 主界面 点击 \u0026ldquo;Factory Reset\u0026rdquo; 双清 (不能漏这一步, 某则脏刷将导致各种问题, 我第一次刷忘记双清, 直接 boot loop 加定位失灵), 然后点击 \u0026ldquo;Apply Update\u0026rdquo;, 点击 \u0026ldquo;Apply from ADB\u0026rdquo; 进入 adb sideload 模式刷入 LineageOS:\n1  adb sideload lineage-18.1-20210513-nightly-kebab-signed.zip    签名验证失败的话, 点击 \u0026ldquo;Yes\u0026rdquo; 继续刷入即可.\n   (可选操作): 刷入额外的包, 如 GAPPS, Magisk等:\n 如果要刷 GAPPS, 需要在重启进入系统前将其刷入, 其他包则可以在通过系统初始化后重启至 recovery 再刷.\n 下面将以本次刷机为例, 记录刷入 GAPPS 和 Magisk 的过程:\n重启至 recovery, 然后进入 sideload 模式:\n1  adb sideload MindTheGapps-11.0.0-arm64-20210412_124247.zip   在 recovery 主菜单点击 \u0026ldquo;Reboot system now\u0026rdquo;, 即可开机进入系统, 完成初始化后检查谷歌全家桶能否正常运行, 无误后继续以下步骤:\n1 2  adb install Magisk-v23.0.apk adb reboot recovery   重启至 recovery 后, 进入 sideload 模式, 同时将电脑中的 Magisk-v23.0.apk 复制一份, 改名为 Magisk-v23.0.zip:\n1  adb sideload Magisk-v23.0.zip     在 recovery 主菜单点击 \u0026ldquo;Reboot system now\u0026rdquo;, 即可开机进入系统.\n  发现的问题 刷 LOS 的过程中发现了两个问题, 问题和解决方法如下:\n  定位不正常\n第一次刷入时忘记双清, 开机直接 boot loop, 解决后进入系统, 第二天上班时差点钉钉打卡无法定位\u0026hellip;\n解决方法: 刷入 LOS 前双清, 切忌 dirty flash.\n  移动网络网速不正常\n第二次刷入时一切正常, 但切换至移动网络时网速只有 200+k/s, 明显不是5G该有的网速, 后到lineage的 reddit 论坛中发现有人有 同样的情况, 只需根据运营商修改 APN 即可. 刷回 OOS 后, 我进入设置对默认 APN 进行了截图 (此处以联通为例).\n解决方法: 刷入 LOS 后进入设置, 按照截图修改参数即可.\n  截图 正常使用后的一些截图如下:\n修改 APN 后的 speedtest:\n更新界面:\nMagisk 界面:\nLOS 回 OOS 并 ROOT 准备  adb (基本操作了, 没有adb就无法通过指令控制手机) 9008救砖包 (随时准备好救砖) Magisk-v23.0.apk OOS全量包 (这里用的是 OOS Open Beta 4) Payload Dumper for Win  具体步骤  以下步骤以 LOS 刷至 OOS 为例, 刷机前记得 做好备份.\n  参考视频: https://www.youtube.com/watch?v=zKd_mO7f1eM\n   关机, 静置手机待其完全关闭, 电脑解压并打开下载好的 救砖包, 打开 MsmDownloadTool V4.0.exe, 选择 Other并下一步, target 项选择 O2, 表示刷入 OOS.\n  同时按下手机的 音量+ 和 音量-, 插入 USB 线与电脑连接, 待出现 COM 口后, 点击 start, 看到开始加载进度条后方可松开音量键, 等待刷机完毕后, 手机将清除所有数据并自动重启.\n  完成初始化后进入系统, 打开 开发者选项 并勾选 OEM 解锁 以及 USB 调试.\n  解锁手机:\n1 2 3 4  adb decices adb reboot bootloader fastboot devices fastboot oem unlock   通过音量键和电源键确认解锁手机, 然后完成初始化进入系统.\n  将下载好的 OOS Open Beta 4 全量包放入手机根目录, 进入设置, 系统升级, 选择 从本地更新, 然后选择根目录中的全量包进行 full update, 安装完毕后重启手机.\n  在电脑端, 将下载好的 OOS 全量包中的 payload.bin 置入 \u0026ldquo;/payload_dumper-win64\u0026rdquo; 的 \u0026ldquo;/input\u0026rdquo; 文件夹中, 运行 payload_dumper.exe, 运行完毕后, 在 \u0026ldquo;/output\u0026rdquo; 中找到 boot.img 并复制到手机目录中, 如 \u0026ldquo;/Download\u0026rdquo; 中.\n  安装并打开 \u0026ldquo;Magisk Manager\u0026rdquo;, 在首页点击 \u0026ldquo;安装\u0026rdquo;, 选择 \u0026ldquo;选择并修补一个文件\u0026rdquo;, 选择 \u0026ldquo;/Download/boot.img\u0026rdquo; 后点击 \u0026ldquo;开始\u0026rdquo;, Magisk Manager 将生成一个命名类似 magisk_patch.img 的文件在 \u0026ldquo;/Download\u0026rdquo; 中, 将其复制进电脑.\n  将手机连接至电脑, 输入以下指令:\n1 2 3 4  adb devices adb reboot bootloader fastboot devices fastboot flash boot magisk_patch.img   刷入完毕后重启至系统, 打开 Magisk Manager 检查 root 状态.\n  结尾 Root 之后, 又可以玩回很多以前的东西了, 比如把字体改成 Ubuntu 格式, 启用黑域, Swift Backup, Quick Switch等等, 倒是最近的 Xposed 框架又有新的 LSPosed, 简称 \u0026ldquo;LSP\u0026rdquo;, 是个轻量级的框架, 模块商店的模块还很少, 但是装个 WX 模块还是绰绰有余的.\n再说到动画方面, LOS 的动画流畅度简直吊打 OOS 的, 就比如点开微信信息推送和横屏返回桌面的动画, 一经比较便高下立判, OOS 小修小补这么久, 这个导航栏手势改得真是没眼看\u0026hellip;\n当然, 稳定性方面 OOS 肯定是 LOS 比不了的, 毕竟 LOS 只是一个个人维护的第三方 ROM, 没记错的话开发者 Luk1337 已经从一加6一路维护到一加8T了, 不愧是大佬👍\n","permalink":"https://cgcel.github.io/posts/2021/05/17/","summary":"前言 距离一加 8T 的发布已经过去了大半年, 据说一加 8T 的 ColorOS 会在6月底释出, 大家都说大氢亡了🥴, 但是我不用氢啊🤡, 加上氧最近也用的有些腻了, 正好前一段时间关注到 8T 的 xda 论坛 挺活跃的, 已经有不少的 ROM 可以刷了:\n于是我就打算利用空闲时间刷一刷手里的 8T 解解馋, 玩累了正好回 ColorOS (如果一加不鸽的话\u0026hellip;)\n本篇将分为两大部分来记录, 分别是:\n OOS 刷 LOS 的记录 LOS 刷回 OOS 并 root 的记录  OOS 刷 LOS 准备 在准备刷机前, 我们需要 备份好数据, 并安装或下载好以下内容 (下载包以本篇博客日期为准, 如参考则需尽量下载最新包):\n adb (基本操作了, 没有adb就无法通过指令控制手机) 9008救砖包 (随时准备好救砖) lineage-18.1-20210513-nightly-kebab-signed.zip lineage-18.1-20210513-recovery-kebab.img copy-partitions-20210323_1922.zip GAPPS Magisk-v23.0.apk  具体步骤 详细刷机步骤参考 官方文档 , 下面我将按照具体指令来总结, 这样比较明了, 不用看详细的文字解释:","title":"从OOS到LOS -- 一加8T的刷机记录"},{"content":"起因 ZeroTier 我从去年开始第一次使用, 用来给家里的树莓派做内网穿透, 不过中间因为3B当做个小服务器没什么好玩的就中断了.\n去年年底双十一从闲鱼如了一台 4G RAM 的4B (有点后悔没耐心等 8G 版本), 刷了 RaspiOS 之后就拿来跑PT站的签到脚本和当做下载机使用, 顺便安装了 ZeroTier One, 加入我的 ZeroTier Network, 如此一来在外也能较为轻松地访问到我的 pi.\n但是由于 ZeroTier 的官网在国内访问较慢, 每次需要通过新加入成员或者管理成员都要花一点时间登录官网并管理, 一开始还不觉得麻烦, 后来加入成员越来越多, 也邀请朋友一起加入, 这样管理起来就比较麻烦. 恰巧此时从 ZeroTier 官网上看到他们有官方的 API 可供用户调用, 于是我申请了 API Key, 短暂测试之后决定写一个 Telegram Bot 帮助监控以及管理我的 ZeroTier Network.\nAPI 调用测试 根据 官方文档 说明, 使用 postman 进行 API 调用测试, 根据指示, 在 header 中按照格式加入 API Key 即可请求到数据, 如下图:\nBot 设计 本 bot 使用 Telegram Bot 的第三方库 pyTelegramBotAPI 来实现, 代码部分主要包括两个部分:\n Bot 命令以及定时任务 ZeroTier API 调用  初期版本 初期的版本通过在 config.yaml 文件中添加用户 ID 来添加管理员, 并通过私聊 bot 的方式来对 Network 进行管理. 这种交互方式在 只有一个管理员的时候还是挺方便的, 只需要直接与 bot 私聊发送指令, 开发到一大半的时候发现一个比较难实现的功能: 当有多个管理员管理的时候, bot 显示管理信息会比较困难 (需要在所有管理员对话框同步修改信息, 以显示是哪位管理员进行了此项操作).\n改进版本 与其说初期版本功能的实现比较绕, 不如说是设计之初就考虑的不周到, 本 bot 想要设计成一个允许多人管理的 bot, 就不能以私聊的方式交互, 而是应该将 bot 添加至群聊中, 让群管理员有权限进行管理, 如此一来逻辑便清晰许多了.\nBot 功能  Show networks info Show network members info Set member name (Admin only) Authorize new member (Admin only) Unauthorize member (Admin only) Delete member (Admin only) Set sub admin (Invite your friends to group chat, set as admin and manage the network with you)  创建私人 ZeroTier Network 管理 Bot 具体步骤 开始   创建你的 ZeroTier Web API Token:\n点击链接创建 API Access Token: https://my.zerotier.com/account\n  创建你的 Telegram Bot:\n发送指令给 @BotFather, 你可以复制以下内容发送至 @BotFather 以编辑你的 bot 指令:\n1 2 3 4 5 6  help - Show commands list. show_network - Show your zerotier networks. set_member_name - Set your member\u0026#39;s name by using this command. auth_member - Authorize a member. unauth_member - Unauthorize a member. delete_member - Delete a member.     拷贝仓库至本地:\n1  $ git clone https://github.com/koonchung/ZeroTierTelegramBot.git     安装依赖:\n1  $ pip3 install -r requirements.txt     编辑 config.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # Fill with your telegram bot token# Create your bot by sending commands to @BotFather in Telegrambot_token:\u0026#34;your_bot_token\u0026#34;# Fill with your zerotier token# Get your own API Access Token at: https://my.zerotier.com/accountzerotier_token:\u0026#34;your_zerotier_web_api_token\u0026#34;# Fill with telegram id which you want to set as adminadmin_id:- your_telegram_id# Fill with refresh seconds, used to check new membersrefresh_seconds:60    运行 Bot\n1 2  $ cd ZeroTierTelegramBot $ python3 zerotiertelegrambot   将 bot 邀请至自建群聊中, 发送 /start@your_bot 至群聊, 然后即可开始管理你的ZeroTier Networks.\n  运行截图   start\u0026amp;help\n  show_network\n  network_info\n  accept\u0026amp;setname\n  auth\u0026amp;setname\n  new_member\n  结尾 项目已发布在 GitHub, 欢迎提意见🤗\n","permalink":"https://cgcel.github.io/posts/2021/05/13/","summary":"起因 ZeroTier 我从去年开始第一次使用, 用来给家里的树莓派做内网穿透, 不过中间因为3B当做个小服务器没什么好玩的就中断了.\n去年年底双十一从闲鱼如了一台 4G RAM 的4B (有点后悔没耐心等 8G 版本), 刷了 RaspiOS 之后就拿来跑PT站的签到脚本和当做下载机使用, 顺便安装了 ZeroTier One, 加入我的 ZeroTier Network, 如此一来在外也能较为轻松地访问到我的 pi.\n但是由于 ZeroTier 的官网在国内访问较慢, 每次需要通过新加入成员或者管理成员都要花一点时间登录官网并管理, 一开始还不觉得麻烦, 后来加入成员越来越多, 也邀请朋友一起加入, 这样管理起来就比较麻烦. 恰巧此时从 ZeroTier 官网上看到他们有官方的 API 可供用户调用, 于是我申请了 API Key, 短暂测试之后决定写一个 Telegram Bot 帮助监控以及管理我的 ZeroTier Network.\nAPI 调用测试 根据 官方文档 说明, 使用 postman 进行 API 调用测试, 根据指示, 在 header 中按照格式加入 API Key 即可请求到数据, 如下图:\nBot 设计 本 bot 使用 Telegram Bot 的第三方库 pyTelegramBotAPI 来实现, 代码部分主要包括两个部分:","title":"我的 ZeroTier Network 管理 bot"},{"content":"开头 年初新冠疫情在武汉爆发, 感染者随着春运人流迅速扩散到全国各地, 彼时人人抢口罩, 甚至连药店的水银体温计都被洗劫一空. 那时每天都很关注自己的身体状况, 每天都需要健康上报以确保能正常回到工作岗位, 因此在淘宝下单了一个红外测温模块 MLX90614ESF-BAA, 用来自制一把测温枪, 及时量出体温. 但由于当时口罩, 测温枪等物资紧缺, 下单后过了很久客服通知说没货并给我退款, 这件事就不了了之.\n直到最近双十一没想到要买些什么东西的时候想起了这个未完成的小项目, 我在淘宝下单并顺利拿到了模块, 经过一番测试后将体温枪组装完毕.\n模块选型 整个项目用到的模块有:\n Arduino Nano * 1 面包板 * 1 MLX90614ESF-BAA 红外测温传感器模块 * 1 按键模块 * 1 OLED 屏模块 * 1  这里面只有测温模块是第一次使用, 该模块可以测量 环境温度 以及 物体温度, 从店家介绍页面摘抄一些型号对照表:\n我选购的最便宜的型号 BAA 测量距离只有 2cm, 而 BCC 为 10cm, DCI 为 1m, 因此在实际测量中超出 2cm 测得的数据将会有明显误差.\n功能实现 按照以上选用的模块, 我按照下图将线路连接完毕:\n代码使用到的库文件如下:\n Wire.h SPI.h Adafruit_GFX.h Adafruit_SSD1306.h Adafruit_MLX90614.h  其中 OLED 和测温模块都是通过 I2C 通信获取数据的, 而按键模块则只需通过检测引脚高低电平来判断是否按下并在代码中添加消抖语句即可.\n功能的实现比较简单, OLED 的坑在做毕设的时候已经踩完了, 现在基本上上手就能显示. 下面贴上完整代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88  #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;SPI.h\u0026gt;#include \u0026lt;Adafruit_GFX.h\u0026gt;#include \u0026lt;Adafruit_SSD1306.h\u0026gt;#include \u0026lt;Adafruit_MLX90614.h\u0026gt; #define SCREEN_WIDTH 128 // OLED display width, in pixels #define SCREEN_HEIGHT 64 // OLED display height, in pixels  // Declaration for an SSD1306 display connected to I2C (SDA, SCL pins) #define OLED_RESET 4 // Reset pin # (or -1 if sharing Arduino reset pin) Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, \u0026amp;Wire, OLED_RESET); #define LOGO_HEIGHT 16 #define LOGO_WIDTH 16  Adafruit_MLX90614 mlx = Adafruit_MLX90614(); // constants won\u0026#39;t change. They\u0026#39;re used here to set pin numbers: // 按键引脚 const int buttonPin = 2; // 按键状态 int buttonState = 0; void setup() { // put your setup code here, to run once:  // 初始化串口  Serial.begin(9600); // 初始化MLX90614  Serial.println(\u0026#34;Adafruit MLX90614 READY...\u0026#34;); mlx.begin(); // 初始化OLED模块  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3D for 128x64  Serial.println(F(\u0026#34;SSD1306 allocation failed\u0026#34;)); for (;;); // Don\u0026#39;t proceed, loop forever  } // Show initial display buffer contents on the screen --  // the library initializes this with an Adafruit splash screen.  display.display(); delay(2000); // Pause for 2 seconds  // Clear the buffer  display.clearDisplay(); // 初始化完成后OLED打印信息  oled_print(\u0026#34;READY!\u0026#34;, 1000); // 设置按键引脚为输入  pinMode(buttonPin, INPUT); } void loop() { // put your main code here, to run repeatedly:  // 获取按键状态  buttonState = digitalRead(buttonPin); // check if the pushbutton is pressed. If it is, the buttonState is HIGH:  if (buttonState == HIGH) { delay(200); // 按键消抖  if (buttonState == HIGH) { // 串口打印环境温度以及物体温度  Serial.print(\u0026#34;Ambient = \u0026#34;); Serial.print(mlx.readAmbientTempC()); Serial.print(\u0026#34;*C\\tObject = \u0026#34;); Serial.print(mlx.readObjectTempC()); Serial.println(\u0026#34;*C\u0026#34;); String str = String(mlx.readObjectTempC()) + \u0026#34;*C\u0026#34;; // OLED打印物体温度  oled_print(str, 3000); } } } // 定义OLED打印函数, 参数为: 字符串, 显示时间 void oled_print(String str, int delay_time) { display.clearDisplay(); display.setTextSize(4); // Normal 1:1 pixel scale  display.setTextColor(WHITE); // Draw white text  display.setCursor(0, 0); // Start at top-left corner  display.println(str); display.display(); delay(delay_time); display.clearDisplay(); display.display(); }   组装 组装的想法是收了快递之后看着快递盒突发奇想而来, 把东西简单准备好, 开局一把剪刀, 粘贴全靠热熔胶😎:\n制作过程完全没有技术含量, 最多就是剪了一些塑料泡沫填充空隙, 下面直接放成品图了:\n结尾 总算是把年初定的一个小项目完成了, 在家也算是有点事做了\u0026hellip; 这段时间在公司基本没有做什么项目, 都是在做文档, 写方案, 写标书之类的文案工作, 属实无聊.\n经过这次 DIY 我也想起年初还订了一个机械手拼装玩具, 上淘宝一看已经到货了, 于是补了尾款就等待它到货了, 今天下班路过文具店买了一块切割板, 一把美工刀和一把小剪刀, 期待到货之后的拼装.\n","permalink":"https://cgcel.github.io/posts/2020/11/17/","summary":"开头 年初新冠疫情在武汉爆发, 感染者随着春运人流迅速扩散到全国各地, 彼时人人抢口罩, 甚至连药店的水银体温计都被洗劫一空. 那时每天都很关注自己的身体状况, 每天都需要健康上报以确保能正常回到工作岗位, 因此在淘宝下单了一个红外测温模块 MLX90614ESF-BAA, 用来自制一把测温枪, 及时量出体温. 但由于当时口罩, 测温枪等物资紧缺, 下单后过了很久客服通知说没货并给我退款, 这件事就不了了之.\n直到最近双十一没想到要买些什么东西的时候想起了这个未完成的小项目, 我在淘宝下单并顺利拿到了模块, 经过一番测试后将体温枪组装完毕.\n模块选型 整个项目用到的模块有:\n Arduino Nano * 1 面包板 * 1 MLX90614ESF-BAA 红外测温传感器模块 * 1 按键模块 * 1 OLED 屏模块 * 1  这里面只有测温模块是第一次使用, 该模块可以测量 环境温度 以及 物体温度, 从店家介绍页面摘抄一些型号对照表:\n我选购的最便宜的型号 BAA 测量距离只有 2cm, 而 BCC 为 10cm, DCI 为 1m, 因此在实际测量中超出 2cm 测得的数据将会有明显误差.\n功能实现 按照以上选用的模块, 我按照下图将线路连接完毕:\n代码使用到的库文件如下:\n Wire.h SPI.h Adafruit_GFX.h Adafruit_SSD1306.h Adafruit_MLX90614.h  其中 OLED 和测温模块都是通过 I2C 通信获取数据的, 而按键模块则只需通过检测引脚高低电平来判断是否按下并在代码中添加消抖语句即可.","title":"DIY项目 -- 自制红外测温枪"},{"content":"前言 Android 11 正式版发布已经有一段时间, 前不久在 tg channel 上看到一加6即将适配Android 11 的消息:\n昨晚无聊刷一刷 xda, 发现一加6已经有第三方的A11包可以刷, 正好用晚上的时间试一试.\n准备 因为作者介绍此 ROM 时用红字表明要从Syberia OS Android 10 升级, 所以我先刷Syberia OS Android 10 后再升级 Android 11 版. (后来在文章下留言询问得知当作一个新 ROM 来刷也是 OK 的)\n下载清单 Android 10 部分  SyberiaOS ROM Downloads OOS 10.3.1 Downloads OpenGapps Downloads Latest TWRP Downloads  xda 链接\nAndroid 11 部分  SyberiaOS ROM Download Flame Gapps Download (recommended)  xda 链接\n操作步骤 我用作者描述的方法试了几次都刷不成功, 不是重启到rec就是卡在开机画面, 翻了一下评论区, 借用了一个网友的方法才成功, 为了看起来完整一点, 下面会一起列出所有步骤.\n Connect to PC and boot to bootloader 1  $ adb reboot bootloader    Boot recovery 1  $ fastboot boot twrp.img    Advanced wipe data and cache, format data, factory reset and reboot to bootloader Repeat step 1, 2, 3 Boot recovery Flash OOS, flash twrp, reboot to recovery Repeat step 6 Reboot to system, enable Developer Options and USB Debugging, reboot to recovery Flash Syberia OS Android 10, flash twrp, advanced wipe data and cache, reboot to recovery Flash gapps, reboot to system, enable Developer Options and USB Debugging, reboot to recovery Repeat step 9, 10 Flash Syberia OS Android 11, flash twrp, advanced wipe data and cache, reboot to recovery Flash gapps, reboot to system  总结 按照以上步骤来刷, 不出意外的话应该是可以成功的, 昨晚试了一晚上, 直到半夜十二点多才成功\u0026hellip; 这个 ROM 有毒\u0026hellip; 刷好之后对比了一下, 11 的变动看起来的确是挺少的, 只有轻微的一点点 UI 变化, 好像还有一些隐私的保护之类的.\n下面分享几张截图:\n最后, 虽然能预料到, 一加6 果然是比一加7 先有 Android 11 的包, 一加7 果然还是太弟弟了.\n","permalink":"https://cgcel.github.io/posts/2020/10/03/","summary":"前言 Android 11 正式版发布已经有一段时间, 前不久在 tg channel 上看到一加6即将适配Android 11 的消息:\n昨晚无聊刷一刷 xda, 发现一加6已经有第三方的A11包可以刷, 正好用晚上的时间试一试.\n准备 因为作者介绍此 ROM 时用红字表明要从Syberia OS Android 10 升级, 所以我先刷Syberia OS Android 10 后再升级 Android 11 版. (后来在文章下留言询问得知当作一个新 ROM 来刷也是 OK 的)\n下载清单 Android 10 部分  SyberiaOS ROM Downloads OOS 10.3.1 Downloads OpenGapps Downloads Latest TWRP Downloads  xda 链接\nAndroid 11 部分  SyberiaOS ROM Download Flame Gapps Download (recommended)  xda 链接\n操作步骤 我用作者描述的方法试了几次都刷不成功, 不是重启到rec就是卡在开机画面, 翻了一下评论区, 借用了一个网友的方法才成功, 为了看起来完整一点, 下面会一起列出所有步骤.","title":"Syberia OS (R) for OnePlus 6 刷机体验"},{"content":"前言 最近长江沿岸发生了洪灾, 很多城市街道都被淹了, 在 大佬的指引 下, 我写了个脚本爬取长江水文网各个观测站的水位状况, 并绘图观察水位情况, 因为长江水文网 web 只提供实时数据, 没找到历史数据, 因此需要在服务器定时跑脚本爬数据并自己存起来.\n爬取数据 首先看一下长江水文网的首页, 我们能看到各站水位在一个显眼地方显示:\n这是一个不设防的网站, 所有实时水位数据都能在 http://www.cjh.com.cn/sqindex.html 请求到, 如图所示:\n可以看到json数据就在网页源码中, 我们只需要获取这部分字符串就可以得到所有实时数据.\n使用requests直接请求网页, 并对网页源码进行格式化以及截取:\n1 2 3 4 5 6 7 8 9 10 11 12  import requests url = \u0026#39;http://www.cjh.com.cn/sqindex.html\u0026#39; class CjhData(object): def __init__(self): pass def get_data(self): r = requests.get(url) result = r.text.split()[66][:-1] # 去除字符串最后的分号 return result   此时我们可以得到json字符串:\n1 2 3 4  \u0026#39;[{\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;39500\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60105400\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;寸滩\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;4\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;179.06\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;11600\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;乌 江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60803000\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;武隆\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;4\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;191.71\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;36300\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60107300\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;宜昌\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;5\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;50.41\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;33400\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60108300\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;沙市\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;6\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;41.88\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60111200\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;城陵矶(莲)\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;4\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;33.87\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;53100\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60112200\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;汉口\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;4\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;28.31\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;59700\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60113400\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;九江\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;4\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;22.17\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;76400\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60115000\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;大通\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;5\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;16.01\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;22800\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;洞庭湖\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;61512000\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;城陵矶(七)\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;4\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;33.99\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;13500\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;鄱阳湖\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;62601600\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;湖口\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;5\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;21.79\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60107000\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;茅坪(二)\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;5\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;161.36\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;34600\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;61000\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60106980\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;三峡水库\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;5\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;161.36\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;汉江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;61802500\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;龙王庙\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;6\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;160.78\u0026#39;}, {\u0026#39;oq\u0026#39;: \u0026#39;1870\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;汉江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;61802700\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;丹江口水库\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;6\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;160.78\u0026#39;}]\u0026#39;   通过json库, 将其转成json对象就可以取其中的数据了.\n存储数据 爬取到实时数据后, 我们将数据存储在 mysql 中, 因为脚本会部署到树莓派4上, 所以树莓派上安装的是 mariadb, 这里先说明一下.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  import pymysql class DB(object): def __init__(self): self.con = pymysql.connect(host=\u0026#39;localhost\u0026#39;, user=\u0026#39;root\u0026#39;, password=\u0026#39;password\u0026#39;, database=\u0026#39;yangtze_river_water_level\u0026#39;) self.cur = self.con.cursor() def insert_data(self, oq, q, rvnm, stcd, stnm, tm, wptn, z): # 检查某站某时间的数据是否已存储过, 避免重复存储数据 if self.cur.execute(\u0026#34;select * from water_level where stnm=%sand tm=%s\u0026#34;, (stnm, tm)) == 0: self.cur.execute(\u0026#34;insert into water_level(oq, q, rvnm, stcd, stnm, tm, wptn, z) values (%s, %s, %s, %s, %s, %s, %s, %s)\u0026#34;, (oq, q, rvnm, stcd, stnm, tm, wptn, z)) self.con.commit() else: pass def get_list_stnm(self): self.cur.execute(\u0026#34;select distinct stnm from water_level\u0026#34;) return self.cur.fetchall() def selectByStation(self, station): self.cur.execute(\u0026#34;select * from water_level where stnm=%s\u0026#34;, (station)) data = self.cur.fetchall() return data def delete_duplicate(self): pass def __del__(self): self.cur.close() self.con.close()   在主函数调用函数后, 将爬取到的数据存入数据库中:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import json from get_cjh_data import CjhData from database import DB def main(): cd = CjhData() # 实例化爬虫类 json_str = cd.get_data() # 得到json字符串 json_data = json.loads(json_str) # 将json字符串转成json对象 # print(json_data) db = DB() # 实例化数据库操作类 for item in json_data: # 将json对象中的数据遍历存入数据库中 db.insert_data(item[\u0026#39;oq\u0026#39;], item[\u0026#39;q\u0026#39;], item[\u0026#39;rvnm\u0026#39;], item[\u0026#39;stcd\u0026#39;], item[\u0026#39;stnm\u0026#39;], item[\u0026#39;tm\u0026#39;]/1000, item[\u0026#39;wptn\u0026#39;], item[\u0026#39;z\u0026#39;]) if __name__ == \u0026#39;__main__\u0026#39;: main()   运行成功后, 打开数据库检查结果:\n绘图 第一次使用python画图, 我简单学了一下网上的 matplotlib 的 demo, 修改一些参数就得到了自己想要的图 (这个折线图算是最基础的图形), 有一些小配置要写好, 比如更换字体来让中文得以显示等等:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  import matplotlib.pyplot as plt from pylab import mpl import numpy as np import datetime from database import DB class DrawData(object): def __init__(self): self.db = DB() def draw(self): list_stnm = self.db.get_list_stnm() # 修改字体实现中文显示 mpl.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;Microsoft Yahei\u0026#39;] fig, ax = plt.subplots() ax.set_xlabel(\u0026#34;时间\u0026#34;) ax.set_ylabel(\u0026#34;水位\u0026#34;) ax.set_title(\u0026#34;长江沿岸水位统计\u0026#34;) for station in list_stnm: data = self.db.selectByStation(station) # print(data) list_tm = [] list_z =[] for item in data: timedata = datetime.datetime.fromtimestamp(item[6]) list_tm.append(timedata) list_z.append(float(item[8])) ax.plot(list_tm, list_z, label=station) ax.legend() fig.autofmt_xdate() plt.show()   运行脚本, 可以得到我们想要的折线图:\n2020-07-24 更新: 截至到编辑时间已经爬取到2666条数据😎, 波形图如下:\n部署 在树莓派上安装好所需依赖, 这里将mysql改为mariadb, 操作方法和mysql几乎一样, 因此建好database以及导入table后, 代码也能完美运行. 测试完毕后, 通过 crontab -e 添加定时任务就算基本完成了.\n","permalink":"https://cgcel.github.io/posts/2020/07/18/","summary":"前言 最近长江沿岸发生了洪灾, 很多城市街道都被淹了, 在 大佬的指引 下, 我写了个脚本爬取长江水文网各个观测站的水位状况, 并绘图观察水位情况, 因为长江水文网 web 只提供实时数据, 没找到历史数据, 因此需要在服务器定时跑脚本爬数据并自己存起来.\n爬取数据 首先看一下长江水文网的首页, 我们能看到各站水位在一个显眼地方显示:\n这是一个不设防的网站, 所有实时水位数据都能在 http://www.cjh.com.cn/sqindex.html 请求到, 如图所示:\n可以看到json数据就在网页源码中, 我们只需要获取这部分字符串就可以得到所有实时数据.\n使用requests直接请求网页, 并对网页源码进行格式化以及截取:\n1 2 3 4 5 6 7 8 9 10 11 12  import requests url = \u0026#39;http://www.cjh.com.cn/sqindex.html\u0026#39; class CjhData(object): def __init__(self): pass def get_data(self): r = requests.get(url) result = r.text.split()[66][:-1] # 去除字符串最后的分号 return result   此时我们可以得到json字符串:\n1 2 3 4  \u0026#39;[{\u0026#39;oq\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;39500\u0026#39;, \u0026#39;rvnm\u0026#39;: \u0026#39;长江\u0026#39;, \u0026#39;stcd\u0026#39;: \u0026#39;60105400\u0026#39;, \u0026#39;stnm\u0026#39;: \u0026#39;寸滩\u0026#39;, \u0026#39;tm\u0026#39;: 1595059200000, \u0026#39;wptn\u0026#39;: \u0026#39;4\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;179.","title":"爬取洪灾期间长江沿岸水位并绘图"},{"content":"起因 去年年底开始, 部门里统计每月运维分队保障情况的任务就落到了我们头上, 大家都不是很愿意去做, 毕竟是重复劳动, 没有什么意义, 在信息系统里查起来还比较麻烦, 数据要一个一个地对, 然后根据当月分队的排班情况算到每个分队的统计里, 并按照规则排名以及打分, 一般都是每个月23或者24号开始统计, 正好这个月我 21-24 号放假加调休, 心想终于躲过一劫的我居然在回到公司上班的第一天被通知由我来统计! 无奈之下我只好以最快的速度做完, 但是这样下去什么时候才是个头啊, 于是就萌生了自己造轮子的想法, 正好复习一下自学的 python 爬虫.\n尝试 requests 写些小爬虫的时候, 用 requests 是最方便的. 一般来说模拟登录成功的话也就成功了一半, 后续数据可以轻松获得. 但是信息系统的一些前端渲染的数据无法通过 requests 获得, 比如下面使用 BeautifulSoup 解析后没有数据:\n1  \u0026lt;span id=\u0026#34;lblCount\u0026#34; style=\u0026#34;color:#C00000;font-weight:bold;\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;   selenium 于是我只能用 selenium 来写, 这也是我第一次全程用 selenium 实现功能的爬虫. selenium 的使用也非常简单, 思路就是使用 find_element_by_id() 和 find_element_by_xpath() 来操作浏览器点击或者输入信息, 将响应后的网页源码通过 BeautifulSoup 解析, 得到想要的数据, 如下:\n1  \u0026lt;span id=\u0026#34;lblCount\u0026#34; style=\u0026#34;color:#C00000;font-weight:bold;\u0026#34;\u0026gt;1\u0026lt;/span\u0026gt;   处理数据 有了数据之后还要解决一个问题, 也就是推出各个分队的排班, 以便将爬到的数据算到对应责任分队处, 我是用了建 dict 和 list 的方式, 将4天一周期的分队排班和时间段结合, 得出正确的排班, 同时也新建各种dict用于存放分队运行数据, 如延误行李数, 事前维修次数, 责任分区维修次数, 值班日志以及根据这些数据排序得到的分数等等.\n运行环境   Windows 7-10\n  与本机 Chrome 版本对应的 chromedriver (项目中版本为 Chrome version 89)\n 下载链接1 下载链接2 下载链接3    Microsoft Office 或其他\n  工作原理 编译环境:  Python 3.8.6 (64-bit) Visual Studio Code  安装依赖:  selenium openpyxl bs4 pyyaml tqdm lxml  实现原理:  通过 selenium 调用 chromedriver 打开 chrome, 打开信息系统登录页面并模拟登录 登录成功后请求对应延误行李, 值班日志等页面, 使用 BeautifulSoup, re 爬取数据 对数据进行处理后, 使用 openpyxl 将数据写入 Excel 中 功能调试完成后将 chrome 设置为 headless browser, 优化使用体验  使用方法  打开 config.yaml, 按照指引修改 账号, 密码, 起始日期, 结束日期, 刷新间隔, 航站楼, 内外网访问模式, 运行模式, 其中 刷新间隔 可按需修改, 修改完保存配置 运行 main.exe 或 main.py 程序窗口将显示爬取进度, 运行完毕后, 统计结果 以及 分队排班表 以 Excel 格式保存在 \\output 目录中  后续 脚本我从 v1.0 开始记录, 在使用过程中一直有遇到新的bug, 导致统计数字有问题, 期间也是一直有维护, 修了几个bug, 直到最近更新到了 v2.6.3, 相信统计功能已经接近完美 (flag)\n不过也是多亏了同事一直有帮忙检验表格准确性, 这些 bug 才得以被修复, 如果是我自己用估计也不会发现.\n","permalink":"https://cgcel.github.io/posts/2020/07/06/","summary":"起因 去年年底开始, 部门里统计每月运维分队保障情况的任务就落到了我们头上, 大家都不是很愿意去做, 毕竟是重复劳动, 没有什么意义, 在信息系统里查起来还比较麻烦, 数据要一个一个地对, 然后根据当月分队的排班情况算到每个分队的统计里, 并按照规则排名以及打分, 一般都是每个月23或者24号开始统计, 正好这个月我 21-24 号放假加调休, 心想终于躲过一劫的我居然在回到公司上班的第一天被通知由我来统计! 无奈之下我只好以最快的速度做完, 但是这样下去什么时候才是个头啊, 于是就萌生了自己造轮子的想法, 正好复习一下自学的 python 爬虫.\n尝试 requests 写些小爬虫的时候, 用 requests 是最方便的. 一般来说模拟登录成功的话也就成功了一半, 后续数据可以轻松获得. 但是信息系统的一些前端渲染的数据无法通过 requests 获得, 比如下面使用 BeautifulSoup 解析后没有数据:\n1  \u0026lt;span id=\u0026#34;lblCount\u0026#34; style=\u0026#34;color:#C00000;font-weight:bold;\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;   selenium 于是我只能用 selenium 来写, 这也是我第一次全程用 selenium 实现功能的爬虫. selenium 的使用也非常简单, 思路就是使用 find_element_by_id() 和 find_element_by_xpath() 来操作浏览器点击或者输入信息, 将响应后的网页源码通过 BeautifulSoup 解析, 得到想要的数据, 如下:\n1  \u0026lt;span id=\u0026#34;lblCount\u0026#34; style=\u0026#34;color:#C00000;font-weight:bold;\u0026#34;\u0026gt;1\u0026lt;/span\u0026gt;   处理数据 有了数据之后还要解决一个问题, 也就是推出各个分队的排班, 以便将爬到的数据算到对应责任分队处, 我是用了建 dict 和 list 的方式, 将4天一周期的分队排班和时间段结合, 得出正确的排班, 同时也新建各种dict用于存放分队运行数据, 如延误行李数, 事前维修次数, 责任分区维修次数, 值班日志以及根据这些数据排序得到的分数等等.","title":"最近开的一个爬虫小坑"},{"content":"前言 疫情原因, 机场已经冷清很久了. 但是项目都照常缓慢进行中, 趁这次机会我好好学习了一下STM32的一些基础知识和使用方法. 教程的话看的是正点原子的官网教程, 正点原子的资料应该算是国内STM32初学者入门必学的教程了吧, 听说还有野火的也不错, 网上很多例子都有他们家代码的影子.\n实际使用过程中, 我越来越能体会到Arduino的简便之处, 但是相对的对实现原理会不太在意, 在入门STM32的过程中, 我对一些单片机功能有了更深的了解, 就比如常用的串口功能.\n之前对Arduino的串口编程有过不少实践, 还整理过 Arduino之间的串口通信demo, 本篇文章不对STM32单片机底层寄存器, 官方库文件进行过多解读, 只就Arduino与STM32的串口编程方面进行比较, 结合注释进行适当说明.\n硬件准备  STM32C8T6开发板 STM32RCT6开发板  正文 Arduino串口 首先回顾一下Arduino的串口函数, 可以看以下demo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  String inputString = \u0026#34;\u0026#34;; // a String to hold incoming data  void setup() { // initialize serial:  Serial.begin(9600); } void loop() { while(Serial.available()){ inputString += char(Serial.read()); delay(2); } // print the string when a newline arrives:  if (inputString.length() \u0026gt; 0) { Serial.print(inputString); // clear the string:  inputString = \u0026#34;\u0026#34;; } }   Arduino语言中, 先对串口进行初始化, 然后只需要调用 Serial.available() 来判断串口是否接收到数据, 若串口有数据, 则Serial.available() 大于0且值为串口数据字节数. 接着, 通过循环, 使用 Serial.read() 将串口缓存的数据一字节一字节的存取到实现定义好的空字符串中, 如此便可得到Arduino串口接收到的完整数据.\nSTM32串口 接着结合正点原子的串口demo讲一下STM32的串口初始化以及接收数据, 打印数据的功能.\n串口初始化 STM32RCT6一共有3个硬串口, 以串口3为例, 在项目中导入 usart3.h, usart3.c.\n在 usart3.h 中, 我们定义了接收和发送数据长度, 定义了空字符串, 接收数据状态变量, 数据长度以及串口发送, 清空的函数.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #ifndef __USART3_H #define __USART3_H\t#include \u0026#34;sys.h\u0026#34;  #define USART3_MAX_RECV_LEN\t600\t//最大接收缓存字节数 #define USART3_MAX_SEND_LEN\t600\t//最大发送缓存字节数 #define USART3_RX_EN 1\t//0,不接收;1,接收.  extern char USART3_RX_BUF[USART3_MAX_RECV_LEN]; //接收缓冲,最大USART3_MAX_RECV_LEN字节 extern char USART3_TX_BUF[USART3_MAX_SEND_LEN]; //发送缓冲,最大USART3_MAX_SEND_LEN字节 extern vu16 USART3_RX_STA; //接收数据状态 extern int USART3_RX_BUF_LEN; //用于存放接收数据长度  void usart3_init(u32 bound);\t//串口2初始化 void u3_printf(char* fmt,...); void USART3_SendChar(char c); void USART3_SendString(char *s); void USART3_SendArray(u8 array[], int num); void USART3_ClearBuf(); //清空接收的串口数据  #endif   在 usart3.c 中, 我们对串口3进行初始化:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  void usart3_init(u32 bound) { NVIC_InitTypeDef NVIC_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); // GPIOB时钟  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3,ENABLE); //串口3时钟使能  USART_DeInit(USART3); //复位串口3  //USART3_TX PB10  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; //PB10  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\t//复用推挽输出  GPIO_Init(GPIOB, \u0026amp;GPIO_InitStructure); //初始化PB10  //USART3_RX\tPB11  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //浮空输入  GPIO_Init(GPIOB, \u0026amp;GPIO_InitStructure); //初始化PB11  USART_InitStructure.USART_BaudRate = bound; //波特率一般设置为9600;  USART_InitStructure.USART_WordLength = USART_WordLength_8b; //字长为8位数据格式  USART_InitStructure.USART_StopBits = USART_StopBits_1; //一个停止位  USART_InitStructure.USART_Parity = USART_Parity_No; //无奇偶校验位  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; //无硬件数据流控制  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\t//收发模式  USART_Init(USART3, \u0026amp;USART_InitStructure); //初始化串口\t3  USART_Cmd(USART3, ENABLE); //使能串口  //使能接收中断  USART_ITConfig(USART3, USART_IT_RXNE, ENABLE); //开启中断  //设置中断优先级  NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=2 ; //抢占优先级3  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级3  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道使能  NVIC_Init(\u0026amp;NVIC_InitStructure);\t//根据指定的参数初始化VIC寄存器  TIM4_Int_Init(1000-1,7200-1); //10ms中断  USART3_RX_STA=0; //清零  TIM_Cmd(TIM4,DISABLE); //关闭定时器4  }   以上代码是对串口3的初始化, 这里不再赘述, 唯一有区别的地方是最后3句, 这里采用了定时器4设置的10ms定时, 在串口3接收到数据后开启定时器4, 每10ms读取一字节串口数据, 若10ms内没有收到数据, 则判定数据接收完毕, 此时将串口状态位置0, 表示串口3已经接受完数据, 并关闭定时器4.\n串口中断函数 在初始化中, 可以看到开启了串口中断, 接下来在 usart3.c 中对串口3中断函数进行编写, 代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  void USART3_IRQHandler(void) { u8 res; if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET) //接收到数据  { res =USART_ReceiveData(USART3); if((USART3_RX_STA\u0026amp;(1\u0026lt;\u0026lt;15))==0) //接受未完成  { if(USART3_RX_STA\u0026lt;USART3_MAX_RECV_LEN-1) //判断长度, 小于设定长度则还可以接收数据  { TIM_SetCounter(TIM4,0); //计数器清空  if(USART3_RX_STA==0) //使能定时器4的中断  { TIM_Cmd(TIM4,ENABLE);//使能定时器4, 每10ms接受一帧串口数据  } USART3_RX_BUF[USART3_RX_STA++]=res;\t//记录接收到的值, 同时更新数据长度 \tUSART3_RX_BUF_LEN = USART3_RX_STA; } else // 若数据长度超出定义长度则强行将STA最后一位置1  { USART3_RX_STA|=1\u0026lt;\u0026lt;15; //强制标记接收完成 //\tUSART3_ClearBuf();  } } } //当串口3数据与定义字符串相同则执行以下代码 \tif (strcmp(USART3_RX_BUF, \u0026#34;ping\u0026#34;) == 0){ u3_printf(\u0026#34;电机转速: %d\\r\\n温度: %.2f\\r\\n湿度: %.2f\\r\\n\u0026#34;, rate, temp, hum); } }   其中关于 USART3_RX_STA 的运算和条件判断语句我研究了很久, 长时间没有接触C了, 很多位运算都忘了, 加上单片机的寄存器的相关基础掌握得不够熟练, 导致在这一块的理解很慢.\n首先看一下在 usart3.c 中 USART3_RX_STA 的定义, 里面有正点原子和我额外加的注释:\n1 2 3 4 5 6 7 8  //通过判断接收连续2个字符之间的时间差不大于10ms来决定是不是一次连续的数据. //如果2个字符接收间隔超过10ms,则认为不是1次连续数据.也就是超过10ms没有接收到任何数据,则表示此次接收完毕. //接收到的数据状态 (USART3_RX_STA位数的值) //[15]:0,没有接收到数据;1,接收到了一批数据. //[14:0]:接收到的数据长度 //u16为unsigned short是16位, 占2字节 //该变量同时还记录接收到的数据长度 vu16 USART3_RX_STA=0;   引用正点原子在教程里的话: 这里我们设计了一个小小的接收协议：通过这个函数，配合一个数组 USART_RX_BUF[], 一个接收状态寄存器 USART_RX_STA (此寄存器其实就是一个全局变量, 由作者自行添加. 由于它起到类似寄存器的功能, 这里暂且称之为寄存器) 实现对串口数据的接收管理. USART_RX_BUF的大小由 USART_REC_LEN 定义, 也就是一次接收的数据最大不能超过 USART_REC_LEN 个字节. USART_RX_STA 是一个接收状态寄存器其各的定义如下表所示：\n    USART_RX_STA      bit15 bit14 bit13~0   接收完成标志 接收到0x0D标志 接收到的有效数据个数    我们可以知道这个STA变量只用作是否接收完成的标志变量, 第15位为0表示没有接收完, 为1表示接收完成, 因此我们可以在获取串口数据的代码中加入对STA的判断, 比如如下代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  int main(void) { u8 t; u16 times=0; delay_init(); //延时函数初始化  uart3_init(115200); //串口初始化为115200  while(1) { if(USART3_RX_STA\u0026amp;0x8000) //用于判断第15位是否为1, 若为0则计算结果为0, 代码不会执行  { u3_printf(USART3_RX_BUF); //打印字符串  u3_printf(\u0026#34;\\r\\n\u0026#34;); //插入换行  USART3_ClearBuf(); //清空串口缓存数据  USART_RX_STA=0; //调用完串口数据后对STA置0, 表示串口恢复接收状态  } } }   有些网上的demo是 USART3_RX_STA \u0026amp; (1\u0026lt;\u0026lt;15), 其实是一样的, 0x8000和1\u0026laquo;15换算成二进制都是‭1000 0000 0000 0000, 本质上都是对STA最后一位进行判断, 而在代码中强行将STA最后一位置1可以使用 USART3_RX_STA|=0x8000, 道理是一样的. ‬\n当然我们也可以对接收到的数据长度进行判断, 如果大于0则表示串口接收到数据, 将其打印出来即可, 至于串口是否已经接收完成, 在之前的初始化函数中可以看到事先定义并开启了定时器4, 它是用来判断规定时间内串口有没有接收到新数据的, 如果超出定义时间串口没有收到新数据, 则在代码中对状态位赋值表示已经接受完成, 这个方法是根据项目需求制定的, 对串口数据某几位进行校对来判断是否接收完成也完全是可以的.\n总结 通过对STM32的入门学习, 我对单片机的一些功能实现有了更深的了解, 不过这周进度也是慢下来了, 因为物资采购才刚刚上报, 要等模块来了我们才能继续下一步的调试, 接下来就暂时打算测试一下STM32通过TTL-RS485向串口服务器发送数据. 这篇东西居然断断续续写了几天, 今天放假第一天, 结果早上到下午两点多停电, 外面还有装修声, 这个假期体验真是一般\u0026hellip;🤯\n","permalink":"https://cgcel.github.io/posts/2020/06/03/","summary":"前言 疫情原因, 机场已经冷清很久了. 但是项目都照常缓慢进行中, 趁这次机会我好好学习了一下STM32的一些基础知识和使用方法. 教程的话看的是正点原子的官网教程, 正点原子的资料应该算是国内STM32初学者入门必学的教程了吧, 听说还有野火的也不错, 网上很多例子都有他们家代码的影子.\n实际使用过程中, 我越来越能体会到Arduino的简便之处, 但是相对的对实现原理会不太在意, 在入门STM32的过程中, 我对一些单片机功能有了更深的了解, 就比如常用的串口功能.\n之前对Arduino的串口编程有过不少实践, 还整理过 Arduino之间的串口通信demo, 本篇文章不对STM32单片机底层寄存器, 官方库文件进行过多解读, 只就Arduino与STM32的串口编程方面进行比较, 结合注释进行适当说明.\n硬件准备  STM32C8T6开发板 STM32RCT6开发板  正文 Arduino串口 首先回顾一下Arduino的串口函数, 可以看以下demo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  String inputString = \u0026#34;\u0026#34;; // a String to hold incoming data  void setup() { // initialize serial:  Serial.","title":"STM32的串口学习总结"},{"content":"写在前面 手上的一加7已经 root 了一个多月, 一加的更新迟迟不来, 安全补丁还停留在3月份的, 终于在今天 Oxygen Updater 推送了 OB13 更新, 于是我赶紧下下来, 尝试一下保留 root 状态的 OTA 升级.\n操作步骤 网上冲浪一下就可以找到很多教程, 不过多数是英文的, 因为一加在国内还不够主流. 总结一下基本步骤如下:\n 下载全量包, 进入系统更新 - 选择本地安装, 安装完毕后不要重启 在 magisk manager 中安装 TWRP A/B Retention Script 打开 magisk manager, 卸载 - 还原原厂镜像, 卸载成功后不要重启 在 magisk manager 中, 点击安装 - 安装到未使用的槽位(OTA后) - 点击重启  注意重启后手机 (可能) 会重启两次, 不用进行其他操作, 等待其重启完成即可.\n具体操作 为了记录得详细一点, 我截了一些图, 下面将按照步骤贴出.\n1.下载/安装全量包 在 Oxygen Updater 中下载全量包.\n进入设置并选择本地安装, 一般全量包都会被下载至根目录.\n安装完毕后不要重启, 直接退出升级界面即可.\n2. 安装 TWRP A/B Retention Script 在magisk manager中下载安装 TWRP A/B Retention Script, 安装完成后返回magisk manager主界面.\n3. 卸载magisk 打开 magisk manager, 卸载 - 还原原厂镜像, 卸载成功后不要重启\n4. 安装magisk到另一个槽位 现在的安卓机都是 A/B 分区的, 系统的安装/更新是装至当前运行系统的另一个槽位中, 也就是未激活的槽位.\n在 magisk manager 中, 点击安装 - 安装到未使用的槽位(OTA后) - 点击重启\n5. 重启手机并检验 在 magisk manager 中点击重启后, 手机 (可能) 会执行两次重启, 此时不用担心变砖(狗头), 等他自己重启完成就行了.\n重启完成后, 我们可以看到系统已经更新至 OB13.\n然后随便下一个 app 检测一下手机是否保持了 root 状态.\n总结 学会这个方法之后, 以后如果还买一加就可以到手就 root 了 (如果还买的话), 真是美滋滋, 好了总结完毕.\n","permalink":"https://cgcel.github.io/posts/2020/05/07/","summary":"写在前面 手上的一加7已经 root 了一个多月, 一加的更新迟迟不来, 安全补丁还停留在3月份的, 终于在今天 Oxygen Updater 推送了 OB13 更新, 于是我赶紧下下来, 尝试一下保留 root 状态的 OTA 升级.\n操作步骤 网上冲浪一下就可以找到很多教程, 不过多数是英文的, 因为一加在国内还不够主流. 总结一下基本步骤如下:\n 下载全量包, 进入系统更新 - 选择本地安装, 安装完毕后不要重启 在 magisk manager 中安装 TWRP A/B Retention Script 打开 magisk manager, 卸载 - 还原原厂镜像, 卸载成功后不要重启 在 magisk manager 中, 点击安装 - 安装到未使用的槽位(OTA后) - 点击重启  注意重启后手机 (可能) 会重启两次, 不用进行其他操作, 等待其重启完成即可.\n具体操作 为了记录得详细一点, 我截了一些图, 下面将按照步骤贴出.\n1.下载/安装全量包 在 Oxygen Updater 中下载全量包.\n进入设置并选择本地安装, 一般全量包都会被下载至根目录.","title":"一加7 OTA升级系统并保留root记录"},{"content":"前言 前一阵大佬给了块 RFID 读写模块让我们研究, 正好别人没有板子, 我就先一步拿着我的 nano 和 esp8266 去办公室玩玩了.\n什么是RFID? 简介 无线射频识别即射频识别技术（Radio Frequency Identification，RFID），是自动识别技术的一种，通过无线射频方式进行非接触双向数据通信，利用无线射频方式对记录媒体（电子标签或射频卡）进行读写，从而达到识别目标和数据交换的目的，其被认为是21世纪最具发展潜力的信息技术之一。\n无线射频识别技术通过无线电波不接触快速信息交换和存储技术，通过无线通信结合数据访问技术，然后连接数据库系统，加以实现非接触式的双向通信，从而达到了识别的目的，用于数据交换，串联起一个极其复杂的系统。在识别系统中，通过电磁波实现电子标签的读写与通信。根据通信距离，可分为近场和远场，为此读/写设备和电子标签之间的数据交换方式也对应地被分为负载调制和反向散射调制。\n工作原理 RFID技术的基本工作原理并不复杂：标签进入阅读器后，接收阅读器发出的射频信号，凭借感应电流所获得的能量发送出存储在芯片中的产品信息（Passive Tag，无源标签或被动标签），或者由标签主动发送某一频率的信号（Active Tag，有源标签或主动标签），阅读器读取信息并解码后，送至中央信息系统进行有关数据处理。\n一套完整的 RFID 系统， 是由阅读器与电子标签也就是所谓的应答器及应用软件系统三个部分所组成，其工作原理是阅读器（Reader）发射一特定频率的无线电波能量，用以驱动电路将内部的数据送出，此时 Reader 便依序接收解读数据， 送给应用程序做相应的处理。\n测试模块 手头上的模块是 JRD-100, 模块的测试非常顺利, 直接使用厂家提供的 GUI, 首先安装相应驱动, 接着通过 TTL 转 USB 将模块连接上电脑就可以进行 RFID 的读写操作了, 这里只尝试了读码功能, 测试无误后就开始软件方面的开发了. 而模块的操作方式也非常主流, 使用串口指令对其进行操作, 而返回的数据同样会通过串口与主板通信.\n开始编写Arduino库 基本结构 Arduino 的库文件其实就是 C++ 的一个类, 其中必须要引入 Arduino 核心类 Arduino.h, 否则无法在 Arduino 上使用. 其实在之前的使用过程中对 Arduino 库的结构已经有所了解, 基本上都是以下结构:\n1 2 3 4 5 6  -- JrdReader -- example -- xxx xxx.ino JrdReader.h rdReader.cpp   编译环境 在 Arduino IDE 中编写自定义库操作比较简单, 在新建好的 Arduino 项目中新建Tab并命名为 .h 以及 .cpp 文件即可, 如下图所示:\n建好之后的界面如下图所示, 然后就可以开始敲代码编译了.\n头文件与源文件 按照 C++ 语法创建头文件:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026#34;Arduino.h\u0026#34; #ifndef _JRDREADER_H__ #define _JRDREADER_H__  class JrdReader { private: public: JrdReader(); String readOnce(); }; #endif   在源文件中实现头文件的自定义方法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  #include \u0026#34;Arduino.h\u0026#34;#include \u0026#34;JrdReader.h\u0026#34;#include \u0026#34;HardwareSerial.h\u0026#34; /** * read once HEX command */ char read_once_cmd[7] = {0xBB, 0x00, 0x22, 0x00, 0x00, 0x22, 0x7E}; String comdata = \u0026#34;\u0026#34;; JrdReader::JrdReader() { } String JrdReader::readOnce() { String baggageCode = \u0026#34;\u0026#34;; String comstr = \u0026#34;\u0026#34;; // send read_once command  Serial.write(read_once_cmd, 7); delay(50); while (Serial.available() \u0026gt; 0) { char data = Serial.read(); comdata += String(data, HEX); delay(50); } if (comdata.length() \u0026gt; 0) { Serial.print(\u0026#34;comdata: \u0026#34;); for (int i = 0; i \u0026lt; comdata.length(); i++) { comstr += String(comdata[i]); Serial.print(comdata[i]); } Serial.println(); } // clear comdata in order to accept another one.  comdata = \u0026#34;\u0026#34;; // format comstr  comstr.replace(\u0026#34;ffff\u0026#34;, \u0026#34;ss\u0026#34;); comstr.replace(\u0026#34;ff\u0026#34;, \u0026#34;\u0026#34;); comstr.replace(\u0026#34;ss\u0026#34;, \u0026#34;ff\u0026#34;); Serial.println(\u0026#34;comstr: \u0026#34; + comstr); if (comstr.length() \u0026gt; 13) { // read RFID code  for (int i = 18; i \u0026lt; 28; i++) { baggageCode += comstr[i]; } } else { baggageCode = \u0026#34;读取错误 (Unable to read)\u0026#34;; } return baggageCode; }   由于手头上还有别的任务所以先实现了最简单的单次读码功能, 原理则是将说明书中提供的十六进制串口指令通过 Arduino 的 Serial 函数发送给 JRD-100 模块, 模块处理完毕后会将数据通过串口返回给 Arduino, 此时只需要通过串口接收新信息并按照一定规律格式化, 解析就可以得到想要的数据, 其中因为导入了 Arduino.h 这个核心库文件, 所以我们在开发 Arduino 库文件的时候可以调用一些 Arduino 的编程方法, 比如上方代码中的 Serial.write(), Serial.print() 等函数.\n加载库并使用 按照上述 基本结构 中的项目结构保存文件后, 将文件夹复制到 Arduino 的 libraries 文件夹中, 或者将文件夹打包成 .zip 格式, 然后在 Arduino IDE 中它通过 项目-加载库-添加.ZIP库 的方法添加, 然后最好重启一下 Arduino IDE, 此时就可以直接在新建的 .ino 文件中引入自定义的库文件了.\n后续计划 这个库可以写的方法远不止一个, 比如读取多次, 写码等方法, 后续应该会加上, 同时已经实现的 readOnce() 方法的读取率还有待提高, 估计与函数延时有一定关系, 需要慢慢调试得到最佳的数据接收间隔.\n编译环境的摸索 Arduino 的 IDE 由于没有代码补全以及文件管理而广受诟病, 于是我们可以通过很多第三方IDE结合插件来进行 Arduino 开发, 比较常用的有 VS code, sublime, code blocks等等, 我也同样都尝试过, 但是都遇到了各种各样的问题, 最终回到了官方的 IDE 进行开发, 只能说第三方的额插件虽然支持, 但是存在很多缺陷, 比如路径常常需要导入, 只支持到一些版本的 Arduino IDE 等等, 希望官方的编译器能够支持更多功能, 让开发变得简单吧.\n结尾 可能这是博客创建到现在最长的一篇了, 毕竟前面复制了一大段介绍🤓, 那么就先到此为止吧, 下面附上一些参考网址:\n https://baike.baidu.com/item/%E5%B0%84%E9%A2%91%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/9524139?fromtitle=RFID\u0026amp;fromid=497249 https://www.arduino.cc/en/Hacking/libraryTutorial https://www.arduino.cc/en/Reference/APIStyleGuide  ","permalink":"https://cgcel.github.io/posts/2020/04/26/","summary":"前言 前一阵大佬给了块 RFID 读写模块让我们研究, 正好别人没有板子, 我就先一步拿着我的 nano 和 esp8266 去办公室玩玩了.\n什么是RFID? 简介 无线射频识别即射频识别技术（Radio Frequency Identification，RFID），是自动识别技术的一种，通过无线射频方式进行非接触双向数据通信，利用无线射频方式对记录媒体（电子标签或射频卡）进行读写，从而达到识别目标和数据交换的目的，其被认为是21世纪最具发展潜力的信息技术之一。\n无线射频识别技术通过无线电波不接触快速信息交换和存储技术，通过无线通信结合数据访问技术，然后连接数据库系统，加以实现非接触式的双向通信，从而达到了识别的目的，用于数据交换，串联起一个极其复杂的系统。在识别系统中，通过电磁波实现电子标签的读写与通信。根据通信距离，可分为近场和远场，为此读/写设备和电子标签之间的数据交换方式也对应地被分为负载调制和反向散射调制。\n工作原理 RFID技术的基本工作原理并不复杂：标签进入阅读器后，接收阅读器发出的射频信号，凭借感应电流所获得的能量发送出存储在芯片中的产品信息（Passive Tag，无源标签或被动标签），或者由标签主动发送某一频率的信号（Active Tag，有源标签或主动标签），阅读器读取信息并解码后，送至中央信息系统进行有关数据处理。\n一套完整的 RFID 系统， 是由阅读器与电子标签也就是所谓的应答器及应用软件系统三个部分所组成，其工作原理是阅读器（Reader）发射一特定频率的无线电波能量，用以驱动电路将内部的数据送出，此时 Reader 便依序接收解读数据， 送给应用程序做相应的处理。\n测试模块 手头上的模块是 JRD-100, 模块的测试非常顺利, 直接使用厂家提供的 GUI, 首先安装相应驱动, 接着通过 TTL 转 USB 将模块连接上电脑就可以进行 RFID 的读写操作了, 这里只尝试了读码功能, 测试无误后就开始软件方面的开发了. 而模块的操作方式也非常主流, 使用串口指令对其进行操作, 而返回的数据同样会通过串口与主板通信.\n开始编写Arduino库 基本结构 Arduino 的库文件其实就是 C++ 的一个类, 其中必须要引入 Arduino 核心类 Arduino.h, 否则无法在 Arduino 上使用. 其实在之前的使用过程中对 Arduino 库的结构已经有所了解, 基本上都是以下结构:\n1 2 3 4 5 6  -- JrdReader -- example -- xxx xxx.","title":"我的第一个Arduino库"},{"content":"前言 在家中闲来无事, 想起了积灰已久的树莓派3B, 决定来捣鼓一番, 此前试过使用花生壳的免费内网穿透服务, 体验一般, 从舍友那听说可以用 frp 来实现, 于是准备试一试. frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。\n准备 首先准备好以下物品:\n 树莓派3B PC 一台 VPS 一台 显示器 (用于树莓派初始化, 根据自己的情况可以使用别的方式)  配置过程 1. 初始化树莓派 首先在树莓派上安装系统, 我安装的是 Raspbian Buster with desktop, 将系统镜像刷写进SD卡后, 通过接入显示器的方式控制树莓派联网, 开启 SSH 以及 VNC , 这里详细过程就不记录, 算是玩树莓派的基本操作了. 然后我们找到树莓派的 IP, 然后使用 xshell 连接树莓派, 初始化树莓派的过程到此结束.\n2. 准备VPS 这次我租了 VirMach 的服务器, 最低配的 VPS 只需1.25刀/月, 应该是我用过的最便宜的 VPS 了, 不过 IP 处于被半 ban 的状态, 挂上代理才能在xshell上稳定连接.\n3. 配置frp frp 是 GitHub 上的开源项目, 可以直接到 https://github.com/fatedier/frp/releases 中下载, 这里, 根据 VPS 选择 frp_0.31.2_linux_amd64.tar.gz, 而树莓派则选择下载 frp_0.31.2_linux_arm.tar.gz. 根据对应的操作系统及架构, 从 Release 页面下载最新版本的程序, 将 frps 及 frps.ini 放到具有公网 IP 的机器上, 将 frpc 及 frpc.ini 放到处于内网环境的机器上. 而实际上每一个压缩包内都包含了这两个文件, 只需要根据机器的类型来进行配置并运行即可 (Server或者Client端).\n在VPS中, 解压压缩包, 编辑frps.ini文件, 按照配置说明, 可以简单进行编辑:\n1 2 3  # frps.ini [common] bind_port = 7000   启动frps.ini:\n1  ./frps -c ./frps.ini   在树莓派中, 解压压缩包, 假设 frps 所在服务器的公网 IP 为 x.x.x.x:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # frpc.ini [common] server_addr = x.x.x.x server_port = 7000 [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000 [VNC] type = tcp local_ip = 127.0.0.1 local_port = 5900 remote_port = 6500   启动frpc.ini:\n1  ./frpc -c ./frpc.ini   启动后, 内网穿透已经完成, 可以看见, 在树莓派中已经配置了ssh以及VNC访问, 其中5900是树莓派VNC的端口. 至此, 配置已经完成, 我们可以在ssh客户端通过x.x.x.x:6000以及在VNC客户端通过x.x.x.x:6500访问树莓派了!\n","permalink":"https://cgcel.github.io/posts/2020/03/11/","summary":"前言 在家中闲来无事, 想起了积灰已久的树莓派3B, 决定来捣鼓一番, 此前试过使用花生壳的免费内网穿透服务, 体验一般, 从舍友那听说可以用 frp 来实现, 于是准备试一试. frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。\n准备 首先准备好以下物品:\n 树莓派3B PC 一台 VPS 一台 显示器 (用于树莓派初始化, 根据自己的情况可以使用别的方式)  配置过程 1. 初始化树莓派 首先在树莓派上安装系统, 我安装的是 Raspbian Buster with desktop, 将系统镜像刷写进SD卡后, 通过接入显示器的方式控制树莓派联网, 开启 SSH 以及 VNC , 这里详细过程就不记录, 算是玩树莓派的基本操作了. 然后我们找到树莓派的 IP, 然后使用 xshell 连接树莓派, 初始化树莓派的过程到此结束.\n2. 准备VPS 这次我租了 VirMach 的服务器, 最低配的 VPS 只需1.25刀/月, 应该是我用过的最便宜的 VPS 了, 不过 IP 处于被半 ban 的状态, 挂上代理才能在xshell上稳定连接.","title":"树莓派使用FRP实现内网穿透记录"},{"content":"在上一篇博客 ViewPager禁用滑动实践和总结 中我总结了禁用 ViewPager 滑动的解决方案, 这也是网上示例的主流解决方法, 但是使用这个方法后, 导致项目中 Fragment 的 RecyclerView 与 ViewPager 的滑动出现冲突, 无法实现效果, 如下图:\n从上图可以看到按照上一篇博客中重写子 Fragment 中的 ViewPager 的 OnInterceptTouchEvent() 和 onTouchEvent() 后, 于子 Fragment 中显示的 RecyclerView 上滑动将无法使用 Activity 的 ViewPager 切换, 只能在 RecyclerView 没有覆盖到的边框位置进行滑动, 这样的操作无疑非常不舒适, 于是我只能继续在网上搜索相关解决方案, 现总结如下.\n修改步骤 与上一篇博客思路一样, 只需要重写 ViewPager 的 canScrollHorizontally() 函数即可, 代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class UnScrollableViewPager extends ViewPager { private boolean scrollable = false; public UnScrollableViewPager(Context context) { super(context); } public UnScrollableViewPager(Context context, AttributeSet attrs) { super(context, attrs); } @Override // 重写该函数, 用于判断是否能水平滑动  public boolean canScrollHorizontally(int direction) { return scrollable; // false表示已经到最右  } }   修改完代码后重新运行, 效果如下, 可见已经实现了预期的效果.\n 参考链接:\nhttps://www.jianshu.com/p/01ad565a80b4\nhttps://www.jianshu.com/p/ce347cf991db\n ","permalink":"https://cgcel.github.io/posts/2020/02/10/","summary":"在上一篇博客 ViewPager禁用滑动实践和总结 中我总结了禁用 ViewPager 滑动的解决方案, 这也是网上示例的主流解决方法, 但是使用这个方法后, 导致项目中 Fragment 的 RecyclerView 与 ViewPager 的滑动出现冲突, 无法实现效果, 如下图:\n从上图可以看到按照上一篇博客中重写子 Fragment 中的 ViewPager 的 OnInterceptTouchEvent() 和 onTouchEvent() 后, 于子 Fragment 中显示的 RecyclerView 上滑动将无法使用 Activity 的 ViewPager 切换, 只能在 RecyclerView 没有覆盖到的边框位置进行滑动, 这样的操作无疑非常不舒适, 于是我只能继续在网上搜索相关解决方案, 现总结如下.\n修改步骤 与上一篇博客思路一样, 只需要重写 ViewPager 的 canScrollHorizontally() 函数即可, 代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class UnScrollableViewPager extends ViewPager { private boolean scrollable = false; public UnScrollableViewPager(Context context) { super(context); } public UnScrollableViewPager(Context context, AttributeSet attrs) { super(context, attrs); } @Override // 重写该函数, 用于判断是否能水平滑动  public boolean canScrollHorizontally(int direction) { return scrollable; // false表示已经到最右  } }   修改完代码后重新运行, 效果如下, 可见已经实现了预期的效果.","title":"ViewPager的嵌套滑动冲突问题解决"},{"content":"开篇 接触 Android 有一段时间了, 起因是帮同事一起做项目, 顺便自己学习, 于是项目一直断断续续进行, 很多控件和功能都是参考《第一行代码》还有网上的例子慢慢探索的, 最近一直在钻 TabLayout 的点击切换, 也就是禁用 ViewPager 的左右滑动切换的牛角尖, 具体效果如下图所示. 网上的例子实在是太千篇一律了, 导致有些地方只要其中一篇阅读量很多的博客没有, 其他转载或者借鉴的博客就都不会写🤪, 下面就记录一下我在原有 TabLayout\u0026amp;ViewPager 基础上修改的示例.\n实现步骤 1. 重写ViewPager 如果要实现禁用滑动的效果, 那么就需要重写 ViewPager, 因为默认是开启滑动的, 具体代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public class NoScrollingViewPager extends ViewPager { private boolean scrollable = false; public NoScrollingViewPager(Context context) { super(context); } public NoScrollingViewPager(Context context, AttributeSet attrs) { super(context, attrs); } @Override // 重写以下两个TouchEvent, 返回false以禁用滑动动作的监听  public boolean onInterceptTouchEvent(MotionEvent ev) { return scrollable; } @Override public boolean onTouchEvent(MotionEvent ev) { return scrollable; } }   以上重写代码都是千篇一律的, 只需要重写两个函数.\n2. 修改对应xml文件 接下来到对应xml修改原来的 ViewPager 为自定义的 NoScrollingViewPger 组件, 代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;android.support.design.widget.TabLayout android:id=\u0026#34;@+id/tab_fragment1\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt;\u0026lt;/android.support.design.widget.TabLayout\u0026gt; \u0026lt;!--\u0026lt;android.support.v4.view.ViewPager--\u0026gt; \u0026lt;!--android:id=\u0026#34;@+id/viewpager_fragment1\u0026#34;--\u0026gt; \u0026lt;!--android:layout_width=\u0026#34;match_parent\u0026#34;--\u0026gt; \u0026lt;!--android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt;\u0026lt;/android.support.v4.view.ViewPager\u0026gt;--\u0026gt; \u0026lt;com.elvin.tablayouttest.NoScrollingViewPager android:id=\u0026#34;@+id/viewpager_fragment1\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt;\u0026lt;/com.elvin.tablayouttest.NoScrollingViewPager\u0026gt; \u0026lt;/LinearLayout\u0026gt;   我将原本的 ViewPager 控件备注以便比较, 其实就是替换为自定义的 NoScrollingViewPager.\n3. 修改主函数代码 到了最后一步, 回到主代码中, 结合我的示例, 在 Fragment 中加入 TabLayout 以及 ViewPager.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public class Fragment1 extends Fragment { private View view; private TabLayout tabLayout; private FragmentOneAdapter fragmentOneAdapter; private ViewPager noScrollingViewPager; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { view = inflater.inflate(R.layout.fragment1, container, false); initView(); return view; } private void initView() { tabLayout = (TabLayout) view.findViewById(R.id.tab_fragment1); noScrollingViewPager = (ViewPager) view.findViewById(R.id.viewpager_fragment1); fragmentOneAdapter = new FragmentOneAdapter(getChildFragmentManager()); noScrollingViewPager.setAdapter(fragmentOneAdapter); tabLayout.setupWithViewPager(noScrollingViewPager); } }   结尾 整个功能到这里就实现了, 其实是一个很简单的功能, 但是大多数例子都是缺少第三步的, 看得我这个小白一头雾水 (你倒是讲完啊) 只能说网上的实例质量参差不齐, 或者说很多坑要自己踩过才会知道.\n","permalink":"https://cgcel.github.io/posts/2020/02/08/","summary":"开篇 接触 Android 有一段时间了, 起因是帮同事一起做项目, 顺便自己学习, 于是项目一直断断续续进行, 很多控件和功能都是参考《第一行代码》还有网上的例子慢慢探索的, 最近一直在钻 TabLayout 的点击切换, 也就是禁用 ViewPager 的左右滑动切换的牛角尖, 具体效果如下图所示. 网上的例子实在是太千篇一律了, 导致有些地方只要其中一篇阅读量很多的博客没有, 其他转载或者借鉴的博客就都不会写🤪, 下面就记录一下我在原有 TabLayout\u0026amp;ViewPager 基础上修改的示例.\n实现步骤 1. 重写ViewPager 如果要实现禁用滑动的效果, 那么就需要重写 ViewPager, 因为默认是开启滑动的, 具体代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public class NoScrollingViewPager extends ViewPager { private boolean scrollable = false; public NoScrollingViewPager(Context context) { super(context); } public NoScrollingViewPager(Context context, AttributeSet attrs) { super(context, attrs); } @Override // 重写以下两个TouchEvent, 返回false以禁用滑动动作的监听  public boolean onInterceptTouchEvent(MotionEvent ev) { return scrollable; } @Override public boolean onTouchEvent(MotionEvent ev) { return scrollable; } }   以上重写代码都是千篇一律的, 只需要重写两个函数.","title":"ViewPager禁用滑动实践和总结"},{"content":"开篇 最近肺炎爆发, 虽然上班了但是因为公司要节省口罩, 所以大部分时间都在家里待岗, 正好电脑上已经不再用 ss, ssr 也准备不用了 (越来越不稳定了) 于是尝试了一下共享 V2Ray 的局域网连接, 很快就成功了, 闲得无事写篇博客记录一下.\n准备  电脑1台 安装好 V2RayN  详细步骤 设置V2RayN 因为现在懒得自己弄, 所以随便找个机场, 拿到订阅链接后在 V2RayN 中更新节点并在设置中允许局域网连接, 同时留意一下本地监听端口, 如图显示是 10808 端口.\n打开移动热点 以 win10 系统为例, 在设置中打开移动热点:\n然后在网络适配器选项中, 查看已经开启的热点并获取ip地址:\n连接热点 首先在设置中查看已开启的代理的手动设置项, 可以看到端口为 10809.\n在手机上连接热点, 并手动设置代理服务器 IP 以及端口, 从上面步骤可知分别为: 192.168.137.1 和 10809.\n到这里就大功告成了, 其他类似的共享到局域网的热点都是差不多的步骤, ssr 的设置也一样.\n","permalink":"https://cgcel.github.io/posts/2020/02/06/","summary":"开篇 最近肺炎爆发, 虽然上班了但是因为公司要节省口罩, 所以大部分时间都在家里待岗, 正好电脑上已经不再用 ss, ssr 也准备不用了 (越来越不稳定了) 于是尝试了一下共享 V2Ray 的局域网连接, 很快就成功了, 闲得无事写篇博客记录一下.\n准备  电脑1台 安装好 V2RayN  详细步骤 设置V2RayN 因为现在懒得自己弄, 所以随便找个机场, 拿到订阅链接后在 V2RayN 中更新节点并在设置中允许局域网连接, 同时留意一下本地监听端口, 如图显示是 10808 端口.\n打开移动热点 以 win10 系统为例, 在设置中打开移动热点:\n然后在网络适配器选项中, 查看已经开启的热点并获取ip地址:\n连接热点 首先在设置中查看已开启的代理的手动设置项, 可以看到端口为 10809.\n在手机上连接热点, 并手动设置代理服务器 IP 以及端口, 从上面步骤可知分别为: 192.168.137.1 和 10809.\n到这里就大功告成了, 其他类似的共享到局域网的热点都是差不多的步骤, ssr 的设置也一样.","title":"V2RayN局域网共享"},{"content":"前言 网上有不少关于 Arduino 串口通信的教程和示例, 但大多是单向通信的或者是照搬 Arduino 官方示例的. 正好我的自动投食机第二版考虑加物联网功能, 需要对两块板子建立串口通信, 于是整理了网上例子和实践写一篇记录.\n硬件准备  Arduino UNO R1 Arduino MEGA 2560 PC一台  库文件  SoftwareSerial.h  代码部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include \u0026lt;SoftwareSerial.h\u0026gt; SoftwareSerial mySerial(10, 11); //Rx, Tx  String data = \u0026#34;\u0026#34;; //定义字符串  void setup() { Serial.begin(9600); mySerial.begin(4800); } void loop() { //软串口接收到字符串时, 在串口监视器打印  while (mySerial.available()) { data += char(mySerial.read()); delay(20); } if (data.length() \u0026gt; 0) { Serial.print(data); data = \u0026#34;\u0026#34;; } //硬串口接收到字符串时,通过软串口将信息发送给另一块板子  while (Serial.available()) { data += char(Serial.read()); delay(20); } if (data.length() \u0026gt; 0) { mySerial.print(data); data = \u0026#34;\u0026#34;; } }   实际编译测试时, 需要留意一些硬件问题, 避免出现僵局:\n UNO 不能使用 pin2, pin3 作为软串口的输入输出口, 否则无法接受信息, 原因待查; 硬串口与软串口的波特率尽量设置成不同的, 以免打印信息混淆; 软串口波特率不宜过高, 容易造成数据乱码, 原因待查;  总结 这一个小小功能在网上还真的是挺难找的, 相似的例程也不会说明需要注意哪些问题, 就是测试成功了就发上来的那种感觉, 不过硬件开发就是要自己结合实际测试才能积累到经验, 顺便记录下来也是一个不错的学习过程.\n","permalink":"https://cgcel.github.io/posts/2019/12/03/","summary":"前言 网上有不少关于 Arduino 串口通信的教程和示例, 但大多是单向通信的或者是照搬 Arduino 官方示例的. 正好我的自动投食机第二版考虑加物联网功能, 需要对两块板子建立串口通信, 于是整理了网上例子和实践写一篇记录.\n硬件准备  Arduino UNO R1 Arduino MEGA 2560 PC一台  库文件  SoftwareSerial.h  代码部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include \u0026lt;SoftwareSerial.h\u0026gt; SoftwareSerial mySerial(10, 11); //Rx, Tx  String data = \u0026#34;\u0026#34;; //定义字符串  void setup() { Serial.","title":"Arduino的主从机双向通信"},{"content":"这是标题 好久没弄博客, 正好换电脑心血来潮重新配一下, 感觉新主题还挺不错的, 近期更新一下文章吧, 大概:)\n","permalink":"https://cgcel.github.io/posts/2019/12/01/","summary":"这是标题 好久没弄博客, 正好换电脑心血来潮重新配一下, 感觉新主题还挺不错的, 近期更新一下文章吧, 大概:)","title":"换个主题"},{"content":"元旦快乐 2018 过去了，发生了不少事情，总体还算顺利(发一篇博客看看视觉效果如何)。\n壹 完成了大大小小的课设，自学了挺多东西吧，参加了实习，找到了工作。\n贰 感觉跟同学也慢慢打成一片了，可能是因为少玩 Ingress 了，今年北蓝年终聚餐也没有去，重生之后借着双倍11级然后就没怎么玩游戏了，大四还是挺忙的，比前三年要更有压力，想的东西更多。\n叁 又是一个忙碌的元旦(大家都开始做课设不过我们组已经快完成了)然后我自己也效率低下地继续着我的毕设，女朋友也有事要忙，所以就当做是普通的一天好了。\n肆 元旦的计划的话，应该就是继续宅在宿舍做毕设，查资料，玩玩手机吧，天气冷我也没有外出的欲望，最多晚上出去吃顿火锅？\n最后 祝元旦快乐，新的一年希望更精彩，偷一张 Bing 壁纸。 ","permalink":"https://cgcel.github.io/posts/2019/01/01/","summary":"元旦快乐 2018 过去了，发生了不少事情，总体还算顺利(发一篇博客看看视觉效果如何)。\n壹 完成了大大小小的课设，自学了挺多东西吧，参加了实习，找到了工作。\n贰 感觉跟同学也慢慢打成一片了，可能是因为少玩 Ingress 了，今年北蓝年终聚餐也没有去，重生之后借着双倍11级然后就没怎么玩游戏了，大四还是挺忙的，比前三年要更有压力，想的东西更多。\n叁 又是一个忙碌的元旦(大家都开始做课设不过我们组已经快完成了)然后我自己也效率低下地继续着我的毕设，女朋友也有事要忙，所以就当做是普通的一天好了。\n肆 元旦的计划的话，应该就是继续宅在宿舍做毕设，查资料，玩玩手机吧，天气冷我也没有外出的欲望，最多晚上出去吃顿火锅？\n最后 祝元旦快乐，新的一年希望更精彩，偷一张 Bing 壁纸。 ","title":"元旦年度总结"},{"content":"前言 翻阅网上的平衡车资料，大概有两个大方向，分别为卡尔曼滤波型和直接的 PID 调节型，前期我参照了卡尔曼滤波型平衡小车的代码，效果不是很好，小车最后连直立也无法做到，也可能是我的调试方法不对，再加上卡尔曼滤波型的代码相对比较复杂，于是我全部推倒重建，尝试后者。\n模块清单:\n 12V 可充电锂电池 Arduino UNO R3 L298N 电机驱动模块 MPU6050 模块 小车底座 杜邦线若干  过程 相较于卡尔曼滤波型，PID 直接调节型对初次做平衡车的新手比较友好，Youtube 上教程很多，同时也有 PID 参数整定的视频教程。\n组装 首先是组装过程，相对比较简单，觉得不放心的可以直接参照视频教程来做视频，整个系统接线图如下：\n调试 进入重要环节，首先我们将代码烧进 Arduino，然后开机试运行，如果不成功，请返回上一步检查。运行成功后，我们首先需要校正 mpu6050，参照视频，我将mpu6050校正了3遍，结果如下：\n对应修改代码参数：\n1 2 3 4 5 6 7 8  mpu.initialize(); //初始化MPU6050 devStatus = mpu.dmpInitialize(); // supply your own gyro offsets here, scaled for min sensitivity // 校正mpu6050模块, 参考https://www.youtube.com/watch?v=ce3eA8nzInE mpu.setXGyroOffset(165); mpu.setYGyroOffset(-14); mpu.setZGyroOffset(5); mpu.setZAccelOffset(528); // 1688 factory default for my test chip   值得一提的是，这一段代码是直接照搬 mpu6050 库的示例代码的，就连备注部分都是一样的。\n校正完毕后，我们需要调节小车的机械中值：\n1 2  double originalSetpoint = 183; //173, 调节小车的稳定中值, 180为默认值, 根据小车实际情况调试   到现在，小车已经能够正常做出反应，我们的调试工作准备开始，对小车进行 PID 参数整定。 参照视频，我们可以大概总结为以下流程：\n 调节 Kp 值，按照从小到大的方向调试，直到小车调节反应过度（低频抖动）后再取一个比较理想的较小值 调节 Kd 值，为了减小抖动，我们需要 PD 控制，按照从小到大的方向调试，直到小车出现高频抖动后再取一个比较理想的较小值，此时小车已经能够直立一段时间 调节 Ki 值，同时 Kp、Kd 值也可以进行微调，直到最后小车能够平稳直立  贴上调试参数：\n   P I D     30 0 0(反应较慢)   50 0 0   60 0 0   100 0 0(低频抖动)   150 0 0   200 0 0   150 0 0.5   150 0 1   150 0 1.5   150 0 2(高频抖动)   150 0 1.2(能直立但有抖动)   150 0 0.8(能直立但没上一组平稳)   150 0 0.9   150 0 1   120 0 1   100 0 1   65 0 1(平稳直立但移动距离比较大)   68 0 1(平稳直立)   68 50 1   68 100 1(太大)   68 40 1   70 0 1   75 0 1   72 0 1   72 0 0.9   70 0 1.05   70 50 1.05   70 60 1.05   70 70 1.05   71 70 1.05   69 70 1.05   69 90 1.05   69 90 1.1   69 90 1.2(稳定直立)   65 90 1.2(电池满电后稳定直立)    将串口输出的PWM值保存并用matlab绘制曲线图:\n总结 从一开始自信满满开始做这个课设到中途受挫（第一次答辩打回重做）再到后来的全部推倒重建，整个过程下来学习到了很多，特别是PID参数的整定，于是想要写一篇博客记录一下。\n代码已上传至GitHub\n参考链接: 吃水不忘挖井人，下面贴上整个制作过程中帮助比较大的前辈们的教程：\nhttps://forum.arduino.cc/index.php?topic=519968.0\nhttps://www.geek-workshop.com/thread-704-1-1.html\nhttps://www.geek-workshop.com/forum.php?mod=viewthread\u0026amp;tid=14868\u0026amp;highlight=PID\nhttps://www.geek-workshop.com/forum.php?mod=viewthread\u0026amp;tid=23\u0026amp;highlight=PID\nhttp://www.51hei.com/bbs/dpj-47816-1.html\nhttps://www.geek-workshop.com/thread-9879-1-1.html\nhttps://maker.pro/arduino/projects/build-arduino-self-balancing-robot\nhttps://github.com/lukagabric/Franko/blob/master/Franko\nhttps://www.youtube.com/watch?v=yL43DSVdEEQ\u0026amp;t\nhttps://www.youtube.com/watch?v=ce3eA8nzInE\nhttps://www.youtube.com/watch?v=uyHdyF0_BFo\n","permalink":"https://cgcel.github.io/posts/2018/12/21/","summary":"前言 翻阅网上的平衡车资料，大概有两个大方向，分别为卡尔曼滤波型和直接的 PID 调节型，前期我参照了卡尔曼滤波型平衡小车的代码，效果不是很好，小车最后连直立也无法做到，也可能是我的调试方法不对，再加上卡尔曼滤波型的代码相对比较复杂，于是我全部推倒重建，尝试后者。\n模块清单:\n 12V 可充电锂电池 Arduino UNO R3 L298N 电机驱动模块 MPU6050 模块 小车底座 杜邦线若干  过程 相较于卡尔曼滤波型，PID 直接调节型对初次做平衡车的新手比较友好，Youtube 上教程很多，同时也有 PID 参数整定的视频教程。\n组装 首先是组装过程，相对比较简单，觉得不放心的可以直接参照视频教程来做视频，整个系统接线图如下：\n调试 进入重要环节，首先我们将代码烧进 Arduino，然后开机试运行，如果不成功，请返回上一步检查。运行成功后，我们首先需要校正 mpu6050，参照视频，我将mpu6050校正了3遍，结果如下：\n对应修改代码参数：\n1 2 3 4 5 6 7 8  mpu.initialize(); //初始化MPU6050 devStatus = mpu.dmpInitialize(); // supply your own gyro offsets here, scaled for min sensitivity // 校正mpu6050模块, 参考https://www.youtube.com/watch?v=ce3eA8nzInE mpu.setXGyroOffset(165); mpu.setYGyroOffset(-14); mpu.setZGyroOffset(5); mpu.setZAccelOffset(528); // 1688 factory default for my test chip   值得一提的是，这一段代码是直接照搬 mpu6050 库的示例代码的，就连备注部分都是一样的。","title":"基于Arduino的自平衡车的调试总结"},{"content":"开篇 前不久入了一加6, 入手第二天就升到了官方的 OxygenOS 9.0 Beta4, 吃到了官方的 pie, 体验下来, 总体感觉如下:\n优点:  指纹支付很方便, 这在氢氧两个 ROM 均有适配 类原生 UI 风格讨喜 后台清除方式分两种模式可调节, 方便不同用户群体 全面屏显示功能调节方便, 充分利用屏幕显示 Dash 闪充充电效率很高  缺点:  系统功能未完善, 比如岛 Island (炼妖壶)等相关 app 无法创建工作模式 动画粗糙, 比如切换最近任务栏时可以明显看见缩略图由原生的棱角突变为一加的圆角卡片 后台限制管理太分散: 一加将自家的后台省电与原生的 AI 省电混合使用, 用户难以分清楚两者相关作用 室内定位体验差, 一加的定位一直以来都受到诟病 (比如 ingress 室内一直在雪花)  总体来说一加的产品在国内算是非常不错的安卓旗舰机了, 今天无聊打开 xda 逛了一下一加6论坛, 发现 Pixel Experience 适配了一加6, 于是在一番准备后, 我开始了刷机.\n前期准备 这是我第三次刷 AB 分区的手机, 上一次操作是用米3和Pixel 2 XL的时候, 因此要做足准备, 不然刷成砖岂不是\u0026hellip;😂\n  查询相关评测\n  这一步其实是必不可少的, 任何 ROM 都会有或多或少的 bug, 要确认该 ROM 在本机上能正常使用我们才能放心去刷, 另外我习惯找比较出名的第三方 ROM, 一是有口碑有质量保证, 二是刷的人多可以借鉴他们的方法和经验, 而 Pixel Experience 是近来大家讨论比较多的 ROM. 我分别在 xda 和 youtube 上查阅, 观看了相关信息, 总结下来刷机顺序如下:\n  Install blue_spark twrp.\n  Clear system, cache, dalvik cache\n  Flash rom and then twrp. Use the latest blu spark recovery.\n  Let the rom boot first. First boot might take 10-15 mins cause.\n  Boot into recovery and then flash magisk if you want to root, then boot into system.\n    环境及刷机包准备\n  解锁bootloader教程\n  adb (不懂的请自行解决)\n  ROM\n  TWRP(img\u0026amp;zip)\n  Magisk (自选)\n    开刷   从开机状态开始操作\n1 2  $ adb reboot bootloader $ fastboot boot name_of_twrp.img    如顺利, 将进入twrp.    刷入\n  wipe → clear system, cache, dalvik cache\n  install → name_of_rom.zip\n  install → name_of_twrp.zip\n  install → magisk.zip →reboot system\n    初始化\n 经过以上流程, 此ROM就算刷完了, ok可以开始体验啦:)    使用感受 系统保留了一些一加的功能:\n一些截图:\n闪充依然见效:\nPS: ingress室内秒定位, 嗯真香\u0026hellip;\n以上.\n","permalink":"https://cgcel.github.io/posts/2018/10/28/","summary":"开篇 前不久入了一加6, 入手第二天就升到了官方的 OxygenOS 9.0 Beta4, 吃到了官方的 pie, 体验下来, 总体感觉如下:\n优点:  指纹支付很方便, 这在氢氧两个 ROM 均有适配 类原生 UI 风格讨喜 后台清除方式分两种模式可调节, 方便不同用户群体 全面屏显示功能调节方便, 充分利用屏幕显示 Dash 闪充充电效率很高  缺点:  系统功能未完善, 比如岛 Island (炼妖壶)等相关 app 无法创建工作模式 动画粗糙, 比如切换最近任务栏时可以明显看见缩略图由原生的棱角突变为一加的圆角卡片 后台限制管理太分散: 一加将自家的后台省电与原生的 AI 省电混合使用, 用户难以分清楚两者相关作用 室内定位体验差, 一加的定位一直以来都受到诟病 (比如 ingress 室内一直在雪花)  总体来说一加的产品在国内算是非常不错的安卓旗舰机了, 今天无聊打开 xda 逛了一下一加6论坛, 发现 Pixel Experience 适配了一加6, 于是在一番准备后, 我开始了刷机.\n前期准备 这是我第三次刷 AB 分区的手机, 上一次操作是用米3和Pixel 2 XL的时候, 因此要做足准备, 不然刷成砖岂不是\u0026hellip;😂\n  查询相关评测\n  这一步其实是必不可少的, 任何 ROM 都会有或多或少的 bug, 要确认该 ROM 在本机上能正常使用我们才能放心去刷, 另外我习惯找比较出名的第三方 ROM, 一是有口碑有质量保证, 二是刷的人多可以借鉴他们的方法和经验, 而 Pixel Experience 是近来大家讨论比较多的 ROM.","title":"一加6 Pixel Experience Android Pie 刷机体验"},{"content":"开篇 回顾我的刷机历程, 每次都是有了想法之后就行动起来了, 经历的是一次又一次的真香警告. 而本次 root 的想法的起因是黑域越来越难用, 让我想用回绿守, 本想着等 9.1 出来之后再 root, 但是每次我都会等不及\u0026hellip; 然后果不其然的踩坑了.\n刷机环境以及刷机包准备  USB驱动 adb环境 TWRP Magisk  其中, twrp 较新版本刷入之后有 bug, 上 youtube 看过教程后, 决定采用 twrp3.2.1.2, 下载时需要下载.img以及.zip文件.\n具体步骤   进入命令行\n  进入 fastboot 界面\n1  $ adb reboot bootloader     解 bootloader 锁\n1  $ fastboot flashing unlock   使用音量键和电源键进行确认, 注意解锁后手机所有数据将会被清除, 要做好备份.\n  刷入第三方 recovery\n1  $ fastboot boot path/twrp.img   刷入成功后, 重启进入 recovery, 此时还需要进入 install, 选择 twrp.zip 包再进行刷入. 缺少这一步的话, 下一次重启还会回到官方recovery.\n  刷入 magisk 在 twrp 的 install 页面选择事先存入手机的 magisk.zip 进行刷入, 刷入后重启即可.\n  结尾 整个过程下来就刷 twrp 出了些问题, 最新版本不能用是什么鬼\u0026hellip;? (勘误: 事实上只是 twrp 的加密, 输入锁屏 PIN 码即可) 好在最后还是解决了问题, 顺便写篇博客记录一下这个坑.\n","permalink":"https://cgcel.github.io/posts/2018/09/09/","summary":"开篇 回顾我的刷机历程, 每次都是有了想法之后就行动起来了, 经历的是一次又一次的真香警告. 而本次 root 的想法的起因是黑域越来越难用, 让我想用回绿守, 本想着等 9.1 出来之后再 root, 但是每次我都会等不及\u0026hellip; 然后果不其然的踩坑了.\n刷机环境以及刷机包准备  USB驱动 adb环境 TWRP Magisk  其中, twrp 较新版本刷入之后有 bug, 上 youtube 看过教程后, 决定采用 twrp3.2.1.2, 下载时需要下载.img以及.zip文件.\n具体步骤   进入命令行\n  进入 fastboot 界面\n1  $ adb reboot bootloader     解 bootloader 锁\n1  $ fastboot flashing unlock   使用音量键和电源键进行确认, 注意解锁后手机所有数据将会被清除, 要做好备份.\n  刷入第三方 recovery\n1  $ fastboot boot path/twrp.","title":"Pixel 2XL root方案记录"},{"content":"开篇 好久没有更新博客, 正好熟悉了一下 ss 通过局域网共享到手机, 于是写一篇博客记录下来.\n详细步骤 打开热点 首先我们打开电脑的热点, 如果没有的话就使用 wifi 共享工具打开热点, 这里使用的是 WiFi 共享精灵(顺便吐槽一下, 我一直没有找到没广告的良心工具, 换来换去还是这个最顺手, 把各种弹窗关掉将就一下吧)\n查看网络连接信息 打开网络连接, 我们可以通过名称来找到刚开启的热点, 如图为本地连接3.\n获取本机IP地址 这是非常重要的一步, 打开 cmd 或其他工具, 输入ipconfig, 第一个本地连接的 ipv4 地址就是了.\nShadowsocks设置 打开 ss 客户端, 右键其图标, 勾选允许其他设备连入.\n手机WiFi手动配置 进入 WiFi 设置, 连接时选择高级选项, 据观察, 如果已经连接过此热点, Android 9.0 可以直接设置, 而 8.1 需要 forget 后重新设置. 如图, proxy 选手动, 然后将本机 IP 地填写进去, 端口亲测 1080 可行, 网上说的 8123 不行 (更正: 需要以 ss 的 proxy 代理端口为准). 其他选项默认即可, 保存后即可科学上网啦.\n","permalink":"https://cgcel.github.io/posts/2018/09/05/","summary":"开篇 好久没有更新博客, 正好熟悉了一下 ss 通过局域网共享到手机, 于是写一篇博客记录下来.\n详细步骤 打开热点 首先我们打开电脑的热点, 如果没有的话就使用 wifi 共享工具打开热点, 这里使用的是 WiFi 共享精灵(顺便吐槽一下, 我一直没有找到没广告的良心工具, 换来换去还是这个最顺手, 把各种弹窗关掉将就一下吧)\n查看网络连接信息 打开网络连接, 我们可以通过名称来找到刚开启的热点, 如图为本地连接3.\n获取本机IP地址 这是非常重要的一步, 打开 cmd 或其他工具, 输入ipconfig, 第一个本地连接的 ipv4 地址就是了.\nShadowsocks设置 打开 ss 客户端, 右键其图标, 勾选允许其他设备连入.\n手机WiFi手动配置 进入 WiFi 设置, 连接时选择高级选项, 据观察, 如果已经连接过此热点, Android 9.0 可以直接设置, 而 8.1 需要 forget 后重新设置. 如图, proxy 选手动, 然后将本机 IP 地填写进去, 端口亲测 1080 可行, 网上说的 8123 不行 (更正: 需要以 ss 的 proxy 代理端口为准). 其他选项默认即可, 保存后即可科学上网啦.","title":"Shadowsocks局域网共享"},{"content":"前期准备 在我接触单片机的时候就已经知道树莓派的厉害, 这是一台低功率计算机, 同时还可以当作一台高性能的单片机使用. 3月的时候入了一台树莓派3b, 一直积灰到现在, 终于在考试, 课设全部结束之后有空玩一玩了.\n系统安装 系统下载 系统安装还不算太麻烦, 直接去 官网 下载镜像即可, 第一次装系统的话还是选官方提供的东西吧, 我们选择下载 Raspbian 系统, 这是专门为树莓派提供的 Debian 系统, 有两个版本可供选择:\n Raspbian Stretch with desktop Raspbian Stretch Lite  前者是带图形界面的版本, 后者是只有命令行页面的轻量级版本, 为了轻便, 我选择了Lite版.\n刷入 Raspbian 下载完毕后, 使用 SDFormatter 将 SD 卡格式化, 然后使用 Win32DiskImager 将系统写进 SD 卡, 类似工具有很多, 自己选用一个即可 (官网更新了官方工具 Raspberry Pi Imager, 使用起来更为方便), SD 卡容量方面, 很多教程都是选择了最低限度的 2GB 的 SD 卡, 然而这都已经是古董级别的卡了, 一般在街上只能买到最低 16GB 的. 使用 Win32DiskImager 写入系统成功后, 会弹窗询问是否格式化 SD 卡, 这时候点取消就行, 不然又要重新写一遍.\n注意事项 据说新版本的 Raspbian 默认关闭了 ssh, 需要先在 SD 卡的 boot 分区新建一个 ssh 文件夹. 将 SD 插入树莓派后供电, 看到绿灯闪烁就是系统运行成功了.\nssh连接 树莓派有多种连接电脑的方式, 比如TTL转USB连接和网线连接, 用的比较多的是网线连接, 网上有很多教程, 放一个 我参考的.\n用网线连接初次尝试可能会比较麻烦, 但试多几次就会熟练了, 一定要按照步骤一步一步来, 不然树莓派就分配不到 IP 地址了.\n更新软件源 使用 ssh 连接上 Pi 的时候, 输入用户名密码就可以登录系统并进行操作了, 默认用户名: Pi, 默认密码: raspberry, 进入命令行页面后, 我们可以通过更换软件源来解决更新速度慢的问题, 我们采用清华源, 按照以下步骤操作:\n使用管理员权限，编辑 /etc/apt/sources.list 文件。参考命令行为：\n$ sudo nano /etc/apt/sources.list\n用 # 注释掉原文件内容，用以下内容取代：\n1 2  deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi   使用管理员权限，编辑 /etc/apt/sources.list.d/raspi.list 文件。参考命令行为：\n$ sudo nano /etc/apt/sources.list.d/raspi.list\n用 # 注释掉原文件内容，用以下内容取代：\n1 2  deb http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui deb-src http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui   保存并退出后, 执行以下命令即可:\n1 2  $ sudo apt-get update $ sudo apt-get upgrade   ","permalink":"https://cgcel.github.io/posts/2018/07/17/","summary":"前期准备 在我接触单片机的时候就已经知道树莓派的厉害, 这是一台低功率计算机, 同时还可以当作一台高性能的单片机使用. 3月的时候入了一台树莓派3b, 一直积灰到现在, 终于在考试, 课设全部结束之后有空玩一玩了.\n系统安装 系统下载 系统安装还不算太麻烦, 直接去 官网 下载镜像即可, 第一次装系统的话还是选官方提供的东西吧, 我们选择下载 Raspbian 系统, 这是专门为树莓派提供的 Debian 系统, 有两个版本可供选择:\n Raspbian Stretch with desktop Raspbian Stretch Lite  前者是带图形界面的版本, 后者是只有命令行页面的轻量级版本, 为了轻便, 我选择了Lite版.\n刷入 Raspbian 下载完毕后, 使用 SDFormatter 将 SD 卡格式化, 然后使用 Win32DiskImager 将系统写进 SD 卡, 类似工具有很多, 自己选用一个即可 (官网更新了官方工具 Raspberry Pi Imager, 使用起来更为方便), SD 卡容量方面, 很多教程都是选择了最低限度的 2GB 的 SD 卡, 然而这都已经是古董级别的卡了, 一般在街上只能买到最低 16GB 的. 使用 Win32DiskImager 写入系统成功后, 会弹窗询问是否格式化 SD 卡, 这时候点取消就行, 不然又要重新写一遍.","title":"树莓派系统安装以及ssh连接"},{"content":"开篇 最近一直对手机的 3.1GB/3.8GB 的内存占用感到不爽, 想要压缩到 2.8GB 左右, 于是开始填坑 gcm-for-mojo , 这是一个获取网页端微信信息并通过 gcm 推送到客户端的 app, 同时他也支持 mipush, hwpush 等等国内平台的推送, 由于手机是 Pixel 2 XL, 原生系统自然用 gcm 就 ok 了, 微信客户端现在内存占用是越来越大了, 把后台关了也有接近300M, 而使用一些工具替代微信的后台接收信息工作, 自然就达到了省电省内存的效果了.\n服务器配置 本人常用微信, 于是就只做了微信的推送, QQ 配置方法类似, 基本上举一反三, 很容易学会. 首先我们在服务器上安装 perl, Ubuntu 16.04 操作如下:\n1  $ sudo apt-get install perl cpanminus git make screen libssl-dev libnet-ssleay-perl libio-socket-ssl-perl   完成后\n1  $ cpanm Mojo::Weixin   我们直接到 GitHub 上看配置步骤, 描述得很详细, 最多几分钟就可以搞定了.\n接下来我们新建一个 wx.pl 文件, 命名随意, 内容如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  use Mojo::Weixin; my $client = Mojo::Weixin-\u0026gt;new(log_encoding=\u0026gt;\u0026#34;utf-8\u0026#34;); $client-\u0026gt;load(\u0026#34;ShowMsg\u0026#34;); $client-\u0026gt;load(\u0026#34;GCM\u0026#34;,data=\u0026gt;{ api_url =\u0026gt; \u0026#39;https://gcm-http.googleapis.com/gcm/send\u0026#39;, api_key=\u0026gt;\u0026#39;AIzaSyB18io0hduB_3uHxKD3XaebPCecug27ht8\u0026#39;, registration_ids=\u0026gt;[\u0026#34;令牌, 客户端获取\u0026#34;], allow_group=\u0026gt;[\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;], # 群聊信息推送白名单 ban_group=\u0026gt;[], allow_discuss=\u0026gt;[], ban_discuss=\u0026gt;[], is_ban_official =\u0026gt;1, # 不接收公众号信息 }); $client-\u0026gt;load(\u0026#34;Openwx\u0026#34;,data=\u0026gt;{ listen =\u0026gt; [ {host=\u0026gt;\u0026#34;服务器ip地址\u0026#34;,port=\u0026gt;140}, ] , #其中, 端口号自定义, 如140, 需要在客户端设置中填入ip:port格式的地址才能开通快速回复功能, 如下图 }); $client-\u0026gt;run();   将 wx.pl 上传至服务器, 使用 nohup perl wx.pl \u0026amp; 使其在后台运行. 这是个效果不太好的方法, 断开 ssh 连接时很容易把进程也关掉, 翻阅教程时我发现可以用另一个方法来实现后台运行:\n screen -S docker perl wx.pl  此时断开 ssh 连接也不受任何干扰, 放置后台成功. 如果想回到 screen, 可以使用以下指令, 结束操作后挂起即可:\n screen -ls screen -r pid  附上一篇 screen 使用教程\n优势与不足 优势:  gcm-for-mojo 配置起来比 EFB 要简单得多,毕竟依赖没有后者多 fcm 推送很及时 自定义设置比较丰富  不足:  比起 EFB, gcm-for-mojo不能显示图片和表情包, 甚至 emoji 也不会显示 使用 nohup 指令让其在后台运行时, 与服务器断开连接后有一次会自动关闭后台进程 不够稳定, 一方面 WebWeixin 本身就是个神奇的东西, 诸如 ItChat, EFB, gcm-for-mojo 这些借助网页版微信获取信息的工具会导致账号被封(一段时间内将无法使用网页登录)  总结 之前用过 EFB1.0, 没多久就弃了, 原因是连接很容易断开, 一旦断开连接就要再重新扫码登录, 而微信无法在本机上扫码登录, 于是就比如借助另一个设备显示二维码, 可以想象有多麻烦, 当然 gcm-for-mojo 也是如此, 正好借此机会对比一下两者的稳定性, 希望这次能用久一点吧🤷‍♀️\n","permalink":"https://cgcel.github.io/posts/2018/07/06/","summary":"开篇 最近一直对手机的 3.1GB/3.8GB 的内存占用感到不爽, 想要压缩到 2.8GB 左右, 于是开始填坑 gcm-for-mojo , 这是一个获取网页端微信信息并通过 gcm 推送到客户端的 app, 同时他也支持 mipush, hwpush 等等国内平台的推送, 由于手机是 Pixel 2 XL, 原生系统自然用 gcm 就 ok 了, 微信客户端现在内存占用是越来越大了, 把后台关了也有接近300M, 而使用一些工具替代微信的后台接收信息工作, 自然就达到了省电省内存的效果了.\n服务器配置 本人常用微信, 于是就只做了微信的推送, QQ 配置方法类似, 基本上举一反三, 很容易学会. 首先我们在服务器上安装 perl, Ubuntu 16.04 操作如下:\n1  $ sudo apt-get install perl cpanminus git make screen libssl-dev libnet-ssleay-perl libio-socket-ssl-perl   完成后\n1  $ cpanm Mojo::Weixin   我们直接到 GitHub 上看配置步骤, 描述得很详细, 最多几分钟就可以搞定了.","title":"Gcm-for-Mojo搭建总结"},{"content":"开篇 终于结束了好几门考试, 有时间更新一下博客了, 就记录一下几天前给一加1卡刷 lineage15.1 吧.\n突如其来的更新 之前有一段时间一直在等官方更新一加1的 lineage15.1, 有空就刷新一下官网, 但始终没有发布, 于是就先把 lineage14.1 刷了. 直到几天前检测更新, 发现有无法 ota 更新的更新, 仔细一看原来是 lineage15.1, 而且已经更新了两版, 于是我迫不及待下载了安装包.\n踩坑 备份后进入 twrp 四清手机, 然后开始卡刷, 然而报错了:\nThis package is for \u0026quot;OnePlus\u0026quot; devices: this is a \u0026quot;A0001\u0026quot;\n经查询, 发现是 twrp 版本太低了, 换了最新的 twrp 一试, 果然成功了, 随后就是刷 gapps, magisk, 常规操作就不说了.\n开机 开机初始化后进入系统, 还是和以往版本一样流畅, 附上一些截图, 短暂使用后只发现了一个奇怪的bug: 刺激战场开伞后就闪退, 进游戏无法返回正在进行的游戏\u0026hellip;下面附上一些截图:升级 今天系统迎来了一次更新, 只有300M左右, 于是就直接用流量下载了, 重启后发现保留了 root 效果, 之前 14.1 时候用 superSU, 每次更新之后就要重新刷一遍才有 root 效果. 顺带一提, 更新之后舍友拿去吃鸡不闪退了 (印度人很喜欢吃鸡, 很多ROM更新之后如果玩不了都会有人在评论反馈😂)\n结尾 终于如愿以偿让备机吃上了 oreo, 体验也很好, 不过这应该是一加1能刷到的最新的版本了吧, 感觉 9.0 希望不大, 不过也很难得了, 毕竟这么老的机型了, 到现在还是很流畅, 刺激战场什么的也压力不大. 改天试一试 rr 好了, 其实 rr 给一加1适配 andoid 8.1 比 lineage 要早, 之前下下来一直刷不上就放弃了. 最后贴一下链接:\n lineageos下载 adb下载 gapps下载 twrp下载  ","permalink":"https://cgcel.github.io/posts/2018/07/04/","summary":"开篇 终于结束了好几门考试, 有时间更新一下博客了, 就记录一下几天前给一加1卡刷 lineage15.1 吧.\n突如其来的更新 之前有一段时间一直在等官方更新一加1的 lineage15.1, 有空就刷新一下官网, 但始终没有发布, 于是就先把 lineage14.1 刷了. 直到几天前检测更新, 发现有无法 ota 更新的更新, 仔细一看原来是 lineage15.1, 而且已经更新了两版, 于是我迫不及待下载了安装包.\n踩坑 备份后进入 twrp 四清手机, 然后开始卡刷, 然而报错了:\nThis package is for \u0026quot;OnePlus\u0026quot; devices: this is a \u0026quot;A0001\u0026quot;\n经查询, 发现是 twrp 版本太低了, 换了最新的 twrp 一试, 果然成功了, 随后就是刷 gapps, magisk, 常规操作就不说了.\n开机 开机初始化后进入系统, 还是和以往版本一样流畅, 附上一些截图, 短暂使用后只发现了一个奇怪的bug: 刺激战场开伞后就闪退, 进游戏无法返回正在进行的游戏\u0026hellip;下面附上一些截图:升级 今天系统迎来了一次更新, 只有300M左右, 于是就直接用流量下载了, 重启后发现保留了 root 效果, 之前 14.1 时候用 superSU, 每次更新之后就要重新刷一遍才有 root 效果. 顺带一提, 更新之后舍友拿去吃鸡不闪退了 (印度人很喜欢吃鸡, 很多ROM更新之后如果玩不了都会有人在评论反馈😂)","title":"一加1卡刷lineage15.1"},{"content":"开篇 5.20前后几天, 六维空间开放注册, 于是久仰大名的我也跑去注册了一个账号, 因为六维空间每日登录都会送5浮云, 因此就有了写一个模拟登录拿每日奖励的脚本的想法, 将其放在校园网登录脚本里面一起跑就美滋滋了.\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  # -*- coding: utf-8 -*- # author: Chan import requests from bs4 import BeautifulSoup url_start = \u0026#39;http://bt.neu6.edu.cn/member.php?mod=logging\u0026amp;action=login\u0026amp;referer=http%3A%2F%2Fbt.neu6.edu.cn%2Fforum.php\u0026#39; url_login = \u0026#39;http://bt.neu6.edu.cn/\u0026#39; url_main = \u0026#39;http://bt.neu6.edu.cn/forum.php\u0026#39; url_test = \u0026#39;http://bt.neu6.edu.cn/home.php?mod=spacecp\u0026#39; class neu6(): def __init__(self, username, password): headers = { \u0026#34;Accept\u0026#34;: \u0026#34;text/html, application/xhtml+xml, application/xml\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN, zh\u0026#34;, \u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age = 0\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;, \u0026#34;Host\u0026#34;: \u0026#34;bt.neu6.edu.cn\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0Win64x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36\u0026#34; } self.session = requests.Session() self.session.headers.update(headers) self.username = username self.password = password r = self.session.get(url_start) soup = BeautifulSoup(r.content, \u0026#39;html.parser\u0026#39;) self.formhash = soup.find(\u0026#34;input\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;formhash\u0026#34;})[\u0026#34;value\u0026#34;] self.action = soup.find(\u0026#34;form\u0026#34;)[\u0026#34;action\u0026#34;] def login(self): try: formdata = { \u0026#34;formhash\u0026#34;: self.formhash, \u0026#34;referer\u0026#34;: url_main, \u0026#34;username\u0026#34;: self.username, \u0026#34;password\u0026#34;: self.password, \u0026#34;questionid\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;answer\u0026#34;: \u0026#34;\u0026#34; } self.session.post(url_login+self.action+\u0026#39;\u0026amp;inajax=1\u0026#39;, data=formdata) r1 = self.session.get(url_main) except: print(\u0026#34;登录失败\u0026#34;) def info(self): try: r2 = self.session.get(url_main) soup = BeautifulSoup(r2.content, \u0026#39;html.parser\u0026#39;) name = soup.find_all(\u0026#34;strong\u0026#34;, {\u0026#34;class\u0026#34;: \u0026#34;vwmy\u0026#34;})[0].get_text() points = soup.find_all(\u0026#34;a\u0026#34;, {\u0026#34;class\u0026#34;: \u0026#34;showmenu\u0026#34;})[ 0].get_text().strip() level = soup.find_all(\u0026#34;a\u0026#34;, {\u0026#34;class\u0026#34;: \u0026#34;xi2\u0026#34;})[ 0].get_text().strip() print(\u0026#34;用户名:\u0026#34;, name) print(points) print(\u0026#34;用户组:\u0026#34;, level) except: print(\u0026#34;获取信息失败\u0026#34;) def main(): neu = neu6(\u0026#39;username\u0026#39;, \u0026#39;passowrd\u0026#39;) neu.login() neu.info() if __name__ == \u0026#39;__main__\u0026#39;: main()   通过看网页源码我们能发现, post 的数据不仅仅是用户名和密码, 他的完整数据如下:\n1 2 3 4 5 6 7 8  formdata = { \u0026#34;formhash\u0026#34;: self.formhash, \u0026#34;referer\u0026#34;: url_main, \u0026#34;username\u0026#34;: self.username, \u0026#34;password\u0026#34;: self.password, \u0026#34;questionid\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;answer\u0026#34;: \u0026#34;\u0026#34; }   幸运的是,这些数据都可以在登录前的页面获取到, 具体做法见代码. 将他放进一键登录程序中, 也可以写到 .bat 文件什么的来轻松登录, 甚至还可以帮舍友, 朋友一起登录.\n如图, 登录成功:P\n结尾 好吧, 其实我只是想玩玩我新建好的博客, 于是就随便拿点小东西发上来了, 有需要的话就拿走吧:P 如果有更好的方法也请告诉我一下, thx.\n","permalink":"https://cgcel.github.io/posts/2018/06/23/","summary":"开篇 5.20前后几天, 六维空间开放注册, 于是久仰大名的我也跑去注册了一个账号, 因为六维空间每日登录都会送5浮云, 因此就有了写一个模拟登录拿每日奖励的脚本的想法, 将其放在校园网登录脚本里面一起跑就美滋滋了.\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  # -*- coding: utf-8 -*- # author: Chan import requests from bs4 import BeautifulSoup url_start = \u0026#39;http://bt.","title":"六维空间自动登录脚本"},{"content":"起因 Jekyll 的加载速度实在是有点慢, 在刚上线不久后, 我又得知了一个页面加载更快的方法: 使用 Hugo 搭建博客.\n搭建环境 到 下载页面 下载 Windows 版本的 hugo, 遇到了坑, 最新版本无法在本地预览页面(v0.42.1)于是我下载了和教程一样的老版本, 以确保能够顺利调试.\n配置 因为才折腾过 jekyll, 加上 hugo 比前者的配置要简单, 所以我很快就改好了 config 文件, 这里要注意的一点是, 要先下载好主题再在根目录使用 hugo server -D 指令, 否则页面会一片空白.\n基础知识学习(Go templates) 列一下适合初学者学习的链接:\n YouTube 官方文档 函数以及变量  模板选择 不得不说模板的选择真是一道难题, 就算是在 hugo 官方提供的模板页面中下载的模板也还是要会有一些 bug\u0026hellip;因为想要 Tags 功能,自己照葫芦画瓢写也有点丑, 所以在上一个模板刚配置完的时候我又换了一个模板, 这个模板刚好有 bug ( baseurl 和 css 等链接之间少了'/') 本菜鸟找了快一个小时才找出来\u0026hellip;\n编写博客 只需要在根目录命令行输入 hugo new ***/***.md 就可以自动创建新文章, 并且hugo会帮忙自动生成标题等信息.\n1 2 3 4 5 6  +++ title= \u0026#34;使用hugo创建博客\u0026#34; date= 2018-06-22T19:34:37+08:00 categories=[\u0026#39;tech\u0026#39;] tags= [\u0026#39;hugo\u0026#39;,\u0026#39;go\u0026#39;,\u0026#39;github.io\u0026#39;] +++   填好以上格式, 就可以开始在下面写博客了, 和 jekyll 非常相似.\n新版本的 hugo 自动生成的 .md 文件格式有点变化, 如下所示:\n1 2 3  title: \u0026#34;换个主题\u0026#34; date: 2019-12-01T23:50:09+08:00 categories: [\u0026#34;daily\u0026#34;]   部署到github.page 和 jekyll 相比, hugo 的部署/文章推送略微麻烦一点, 前者只需要修改并预览检查完毕后直接全部 push 即可, 而 hugo 按照官方文档的方法是先在根目录运行一道指令 hugo --baseUrl=\u0026quot;https://username.github.io\u0026quot; , 在根目录生成 public 文件夹, 然后将 public 文件夹中的所有内容 push 至仓库中. 我查阅了一些其他的自动化方法, 如Travis. 最后嫌配置麻烦, 直接在根目录创建了一个 .bat 文件,将几个指令写进去依次运行, 也算是实现了一键推送的功能, 也算是提供了另一种思路吧.\n1 2 3 4 5 6 7  hugo --theme=pure --baseUrl=\u0026#34;https://koonchung.github.io\u0026#34; cd public git add . git commit -m \u0026#34;auto-uploaded files\u0026#34; git push -u origin master pause   暂告一段落 emm\u0026hellip;写到这里已经半夜一点半了, 那就先告一段落吧, 最后总结一下, 不得不说 hugo 加载的速度比 jekyll 快了不少, 模板配置完成后体验很不错.\n","permalink":"https://cgcel.github.io/posts/2018/06/22/","summary":"起因 Jekyll 的加载速度实在是有点慢, 在刚上线不久后, 我又得知了一个页面加载更快的方法: 使用 Hugo 搭建博客.\n搭建环境 到 下载页面 下载 Windows 版本的 hugo, 遇到了坑, 最新版本无法在本地预览页面(v0.42.1)于是我下载了和教程一样的老版本, 以确保能够顺利调试.\n配置 因为才折腾过 jekyll, 加上 hugo 比前者的配置要简单, 所以我很快就改好了 config 文件, 这里要注意的一点是, 要先下载好主题再在根目录使用 hugo server -D 指令, 否则页面会一片空白.\n基础知识学习(Go templates) 列一下适合初学者学习的链接:\n YouTube 官方文档 函数以及变量  模板选择 不得不说模板的选择真是一道难题, 就算是在 hugo 官方提供的模板页面中下载的模板也还是要会有一些 bug\u0026hellip;因为想要 Tags 功能,自己照葫芦画瓢写也有点丑, 所以在上一个模板刚配置完的时候我又换了一个模板, 这个模板刚好有 bug ( baseurl 和 css 等链接之间少了'/') 本菜鸟找了快一个小时才找出来\u0026hellip;\n编写博客 只需要在根目录命令行输入 hugo new ***/***.md 就可以自动创建新文章, 并且hugo会帮忙自动生成标题等信息.\n1 2 3 4 5 6  +++ title= \u0026#34;使用hugo创建博客\u0026#34; date= 2018-06-22T19:34:37+08:00 categories=[\u0026#39;tech\u0026#39;] tags= [\u0026#39;hugo\u0026#39;,\u0026#39;go\u0026#39;,\u0026#39;github.","title":"使用hugo创建博客"},{"content":"开篇 最近学习 Django 开发网页, 后来由于 Django 开发比较繁琐以及可迁移性较差, 于是转学 flask, 从而有了这一篇文章, 顺便测试一下我的博客发文功能:P\n项目依赖 虽然 flask 较 Django 更轻量, 版本间语法差别不大, 但还是会有一些小坑. 比如在使用 flask-sqlalchemy 时报错, 原因是版本过新或过旧, 另外 flask 的扩展包需要另外安装, 这里注意一下就行. 下面列出个人博客项目的安装依赖 ( python3.5 \u0026amp; python3.6 测试通过):\n Flask_SQLAlchemy==2.1Flask==1.0.2Markdown==2.6.11Flask_Bootstrap==3.3.7.1 数据库 数据库的使用是网页编写的一个非常重要的部分, 基本上读取, 存入, 登录, 注销等等操作都和数据库相关, 本项目使用 sqlite3, 操作起来较为简单. 简单总结一下 flask-sqlalchemy 的使用技巧:\n 路径:   MySQL: mysql+pymysql://username:password@hostname/database Postgres: postgresql://username:password@hostname/database SQLite(Unix): sqlite:////absolute/path/to/database SQLite(Windows): sqlite:///c:/absolute/path/to/database\n  初始化:  1 2 3 4  app = Flask(__name__)\u0026lt;br\u0026gt; app.config[\u0026#39;SQLALCHEMY_DATABASE_URI\u0026#39;] = \u0026#39;sqlite:///E:/code/Python/flask/Elvin_Blog/schema.sql\u0026#39; app.config[\u0026#39;SQLALCHEMY_TRACK_MODIFICATIONS\u0026#39;] = False db = SQLAlchemy(app)    操作语句:  1 2 3 4 5 6 7 8 9  User.query.all() # 搜索所有信息 User.query.get(id) # 搜索对应主键信息 User.query.filter_by(username=\u0026#39;\u0026#39;).all() User.query.filter_by(username=\u0026#39;\u0026#39;).first() db.session.add(User(username,password)) db.session.commit() # 修改信息 User.query.filter_by(id=id).first().username=\u0026#39;newusername\u0026#39; db.session.commit()   自定义过滤器 我希望能将 markdown 格式的内容转化并直接显示, 这就需要用到 flask 的过滤器功能, 阅读了相关文章, 只需要自定义一个过滤器, 代码如下:\n1 2 3 4 5  from flask import Markup import markdown @app.template_filter(\u0026#39;toMarkdown\u0026#39;) def toMarkdown(content): return Markup(markdown.markdown(content))   通过 jinja2 调用时, 只需要 { { content|toMartdown } } 即可.\n用户登录与登出 通过 MD5 加密密码并保存在数据库, 使用 flask 的 session, 登录成功后, 代码添加 session['username'] = username , 同理, 在进入一些诸如管理页面的页面时, 只需要添加 if 'username' in session: 加以判断即可.\n","permalink":"https://cgcel.github.io/posts/2018/06/21/flask%E8%B8%A9%E5%9D%91%E5%92%8C%E6%8E%92%E5%9D%91%E8%AE%B0%E5%BD%95/","summary":"开篇 最近学习 Django 开发网页, 后来由于 Django 开发比较繁琐以及可迁移性较差, 于是转学 flask, 从而有了这一篇文章, 顺便测试一下我的博客发文功能:P\n项目依赖 虽然 flask 较 Django 更轻量, 版本间语法差别不大, 但还是会有一些小坑. 比如在使用 flask-sqlalchemy 时报错, 原因是版本过新或过旧, 另外 flask 的扩展包需要另外安装, 这里注意一下就行. 下面列出个人博客项目的安装依赖 ( python3.5 \u0026amp; python3.6 测试通过):\n Flask_SQLAlchemy==2.1Flask==1.0.2Markdown==2.6.11Flask_Bootstrap==3.3.7.1 数据库 数据库的使用是网页编写的一个非常重要的部分, 基本上读取, 存入, 登录, 注销等等操作都和数据库相关, 本项目使用 sqlite3, 操作起来较为简单. 简单总结一下 flask-sqlalchemy 的使用技巧:\n 路径:   MySQL: mysql+pymysql://username:password@hostname/database Postgres: postgresql://username:password@hostname/database SQLite(Unix): sqlite:////absolute/path/to/database SQLite(Windows): sqlite:///c:/absolute/path/to/database\n  初始化:  1 2 3 4  app = Flask(__name__)\u0026lt;br\u0026gt; app.","title":"flask踩坑和排坑记录"},{"content":"开篇 看到过不少用 github page 搭建的个人博客, 感觉非常方便. 加上前不久刚学了 flask, 对搭建个人博客挺感兴趣, 于是在网上找了一些教程, 开始创建博客, 这里做一下简单的总结.\n创建仓库 在 github 新建项目, 命名格式为 \u0026lt;username\u0026gt;.github.io, 最好先选 private, 因为可能会有很多误操作. 然后在本机 (Windows) 安装环境: gem, jekyll 等等, 安装这些是便于在本地修改网页并且预览,这样就不用每次都 push 到 github 来试了. 不过 Windows 安装起来挺麻烦的, 一定要按照教程一步一步来设置, 跟教程有一些出入的地方要自己判断.\n选择主题 jekyll 的主题有很多,我们可以在 github 和网页上挑选, 本来我想要选一个 md 格式的主题,奈何一时间找不到,于是从 github 上选择了一个纯白的极简主题.\n自定义页面内容 选好主题之后, 通过 git 把代码 clone 到本地, 首先必须要编辑的是 _config.yml,按照个人的信息和需求进行增减改动, 如果不知道该怎么改, 建议多找几个主题对比一下文件内容, 也可以到 YouTube 找一下相关视频教程. 设置完后, 就可以去自定义个人信息和网页显示内容了.\n预览和推送测试 修改完文件后,在项目根目录打开 cmd, 输入 jekyll s, 如果没有报错就表示在本地运行成功了, 此时可以打开浏览器, 进入 127.0.0.1:4000 就可以预览页面. 按照格式命名文章, 如: 2018-6-21-title.md, 在文章开头加上以下内容就可以被识别并更新在主页上了, 非常方便:\n1 2 3 4 5 6  --- layout: post title: \u0026#34;your title\u0026#34; date: 2018-06-21 categories: ---   ","permalink":"https://cgcel.github.io/posts/2018/06/21/github.io%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","summary":"开篇 看到过不少用 github page 搭建的个人博客, 感觉非常方便. 加上前不久刚学了 flask, 对搭建个人博客挺感兴趣, 于是在网上找了一些教程, 开始创建博客, 这里做一下简单的总结.\n创建仓库 在 github 新建项目, 命名格式为 \u0026lt;username\u0026gt;.github.io, 最好先选 private, 因为可能会有很多误操作. 然后在本机 (Windows) 安装环境: gem, jekyll 等等, 安装这些是便于在本地修改网页并且预览,这样就不用每次都 push 到 github 来试了. 不过 Windows 安装起来挺麻烦的, 一定要按照教程一步一步来设置, 跟教程有一些出入的地方要自己判断.\n选择主题 jekyll 的主题有很多,我们可以在 github 和网页上挑选, 本来我想要选一个 md 格式的主题,奈何一时间找不到,于是从 github 上选择了一个纯白的极简主题.\n自定义页面内容 选好主题之后, 通过 git 把代码 clone 到本地, 首先必须要编辑的是 _config.yml,按照个人的信息和需求进行增减改动, 如果不知道该怎么改, 建议多找几个主题对比一下文件内容, 也可以到 YouTube 找一下相关视频教程. 设置完后, 就可以去自定义个人信息和网页显示内容了.\n预览和推送测试 修改完文件后,在项目根目录打开 cmd, 输入 jekyll s, 如果没有报错就表示在本地运行成功了, 此时可以打开浏览器, 进入 127.","title":"github.io博客搭建"}]